% Created 2022-10-08 Sat 23:48
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\author{Oleg Taykalo}
\date{\today}
\title{Interpretation for lazy and curious}
\hypersetup{
 pdfauthor={Oleg Taykalo},
 pdftitle={Interpretation for lazy and curious},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{Interpretation. part 1}
\label{sec:orge2ca1cb}
The core functionality of interpreters might be distilled to two steps.
\begin{enumerate}
\item Parse source code to some internal representation
\item Evaluate the internal representation, so it will be reduced to the result we need.
\end{enumerate}
Here I will do my best to skip as much as possible of the first one.
You dont' need to know quantum physics to be able to swim.

\subsection{Can you do it?}
\label{sec:org400f6f2}
When talking about interpretation  most of the people start thinking about complex things.
register allocation, memory management, grammars and DFAs.
I will try to keep it simple.
As simple as possible without loosing core of the essence.
Let's assume you have a yaml file
\begin{minted}[]{yaml}
bold
- some text
- and more text
\end{minted}

How hard would that be to transform this yaml to the html?
\begin{minted}[]{html}
<b>
  <p>some text</p>
  <p> and more text></p>
</b>
\end{minted}

My guess would be that majority of the developers won't have troubles with doing so.
We're just transforming on tree structure to another tree structure.

And this is the essense of interpretation. We're taking one tree structure and converting it to another tree structure.
If you can convert yaml to html, you're good to go.
\section{Parsing and other friends}
\label{sec:orge63e23e}
Most of the compilers and interpreters books start with parsing.
You neeed to investigate what DFA is, how it is different from NFA, and why regular expressions are not always the best choice.
Then you will follow on grammars. Context free grammars, left recursion elimination and so on.
After that you will be presented with tools that will make your life easier. Yacc, Bison, monadic parsers.
This usually happens 200-300 pages into the book. And while this is very important part of the story, I would like to argue this can be postponed to the point where you actually know what you are doing.
Therefore approach in this book will take us as fast as possible to the actual interpretation, skipping all unnecessary steps if possible.
To begin with we will start with arithmetic expressions.
\subsection{The simplest expressions you can think of}
\label{sec:orgd59d7a3}
Implementing anything on JVM starts with interfaces.
let's us to the same and implement your first Expression
\begin{minted}[]{kotlin}
interface Expression
\end{minted}

It's not much, but we will improve it really fast. Just stay tuned.
\subsubsection{Integer values}
\label{sec:orgf4113f7}
It is hard to do any computations when you don't have numbers.
\begin{minted}[]{kotlin}
data class EInt(val v:Int):Expression
\end{minted}
For now integers are more than enough for us to have. Adding boolean and float values will follow.
\subsubsection{Addition}
\label{sec:orgc50c966}
Adding additional addition to the mix would not be a problem
\begin{minted}[]{kotlin}
data class EAdd(val a:EInt, val b:EInt): Expression

\end{minted}
\subsubsection{Multiplication}
\label{sec:orgcad5e7d}
The same goes for the multiplication
\begin{minted}[]{kotlin}
data class EMul(val a:EInt, val b:EInt): Expression
\end{minted}
\subsection{What else can we add to the expressions}
\label{sec:orgd5a106f}
\subsection{Representing expressions in a code}
\label{sec:org762cddf}
Now we have all the required components to actually start calulating.
How would expression
\begin{minted}[]{kotlin}
2+2
\end{minted}
would look in our data class representation?
\begin{minted}[]{kotlin}
EAdd(2,2)
\end{minted}
Multiplication would not be that different
\begin{minted}[]{kotlin}
5*5
\end{minted}
\begin{minted}[]{kotlin}
EMul(5, 5)
\end{minted}
And if we want to express something more complex, we will just nest them
\begin{minted}[]{kotlin}
(2+2)*5*5
\end{minted}
\begin{minted}[]{kotlin}
EMul(5, EMul(5, EAdd(2 , 2)))
\end{minted}

\section{Evaluating expressions for fun and profit}
\label{sec:org867e9f2}
\subsection{Evaluating integers. As simple as it gets}
\label{sec:org529ade6}
Having expresisons is nice, but why do we need them if we can't calculate them on the fly?
as TDD teaches us, you whould start from the test first.
So be it.
You never can be too slow when doing unit tests. Good coverage for the basics will let you know details of your code workings. As well will save you hours of debugging later on.

\begin{minted}[]{kotlin}
    @Test
    fun testSimpleInteger(){
        assertEquals(EInt(5), eval(EInt(5)))
        assertEquals(EInt(-5), eval(EInt(-5)))
        assertEquals(EInt(0), eval(EInt(0)))
    }
\end{minted}

What would be the easiest implementation of \textbf{eval} to make it run?
I came up with this one.
\begin{minted}[]{kotlin}

fun eval( e:Expression): Expression{
    return e;
}
\end{minted}
Probably would not require a lot of effort to understand what is happening here.
and it also makes our tests green.


\subsection{Evaluating addition}
\label{sec:org9caac3d}
Now we are facing our first real challenge.
How can we evaluate addition?

As usual, let us start with the unit tests, so we don't have a suprises later on.
\begin{minted}[]{kotlin}
 @Test
    fun testSimpleAddition(){
        assertEquals(EInt(5), eval(EAdd(EInt(5), EInt(0))))
        assertEquals(EInt(5), eval(EAdd(EInt(0), EInt(5))))
        assertEquals(EInt(10), eval(EAdd(EInt(7), EInt(3))))
        assertEquals(EInt(7), eval(EAdd(EInt(-3), EInt(10))))
        assertEquals(EInt(6), eval(EAdd(EInt(10), EInt(-4))))
    }
\end{minted}

obviously if we try to run them now, we would have an error

\begin{minted}[]{kotlin}
Expected :EInt(v=5)
Actual   :EAdd(a=EInt(v=5), b=EInt(v=0))
\end{minted}
By the way - this is one of the reasons Kotlin is a nice language for these kind of exercises.
You don't need to write a lot of boilerplates for the \textbf{data class}, string representation looks reasonalbe, and saves some mental space for more important things.

We have a red test. What is the simplest way to make it green?
\begin{minted}[]{kotlin}

fun eval( e:Expression): Expression{
    if(e is EAdd){
        return EInt( e.a.v + e.b.v)
    }
    return e
}
\end{minted}

would this be enough?

Oh wow, tests are green now. But i am not big fan of 'e.a.v' looks very obscure
Green test allows us to do refactoring bit.

\begin{minted}[]{kotlin}
data class EInt(val value:Int):Expression

fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        return EInt(expression.a.value + expression.b.value)
    }
    return expression
}
\end{minted}

Are we done with the addition?

What about more complex example?
\begin{minted}[]{kotlin}
1 + 2 + 3 => 6
assertEquals(EInt(6), eval( EAdd(EInt(1), EAdd( EInt(2),EInt(3)) )))
\end{minted}

And our compiler complains.
\begin{verbatim}
Type mismatch: inferred type is EAdd but EInt was expected
\end{verbatim}

Why is that? Oh yes. in our definition we are expecitng that \textbf{EAdd} expects integers as a parameters.
\begin{minted}[]{kotlin}
data class EAdd(val a:EInt, val b:EInt): Expression
\end{minted}
But now we are trying to pass \textbf{EAdd} as second paramter. Of course we should have an error here.

As usual with TDD approach we fixe it with the simplest way possible
\begin{minted}[]{kotlin}
data class EAdd(val a:Expression, val b:Expression): Expression
\end{minted}

Hopefully it will solve our issue.

But apparently it would not.

We get yet another nasty error in our \textbf{eval} function

\begin{minted}[]{kotlin}
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        return EInt(expression.a.value + expression.b.value)
        //                         ^
        //                         |
        // unresolved reference: value
    }
    return expression
}
\end{minted}

Any ideas?
Sure. \textbf{value} is a field of and integer, and now EAdd works with generic expressions, which might not have a value.
So we need to come up with a way of converting addition result to values.

\begin{minted}[]{kotlin}
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    return expression
}
\end{minted}
This expression is worth to take a closer look.
To execute and addition, we need to be sure that both our parameters are integers.
At the same time when we call \textbf{eval} we would get the \textbf{Expression} as a result.
Therefore we need to convert it to the class we want. In our case that would be \textbf{EInt}.

Of course this little piece of code might rise some questions.
What happens if during \textbf{eval} will return something different from \textbf{EInt} would not that break everything?
What will happen if during \textbf{eval} some error will be raised?
These are very good questions. and we will get to them later. For now let us keep our focus on general picture.

\subsection{Evaluating multiplication}
\label{sec:org64ee93c}
After spending so much time on evaluating addition, expanding our expressions to support multiplication is straighforward.
But first - tests.
\begin{minted}[]{kotlin}
    @Test
    fun testSimpleMultiplication()
    {
        assertEquals(EInt(0), eval(EMul(EInt(0), EInt(42))))
        assertEquals(EInt(0), eval(EMul(EInt(42), EInt(0))))
        assertEquals(EInt(42), eval(EMul(EInt(1), EInt(42))))
        assertEquals(EInt(42), eval(EMul(EInt(42), EInt(1))))
        assertEquals(EInt(4), eval(EMul(EInt(2), EInt(2))))
    }
\end{minted}

and implementation
\begin{minted}[]{kotlin}
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    if(expression is EMul){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value * right.value)
    }
    return expression
}
\end{minted}

As you can see, the implementation is almost identical. The only difference we have Ñ–s the actual operation.

Let's add few more tests to make sure it works if we mix addition and multiplication
\begin{minted}[]{kotlin}
    @Test
    fun testComplicatedMultiplication() {
        assertEquals(EInt(10), eval(EMul(EMul(EInt(1), EInt(5)), EInt(2))))
        assertEquals(EInt(12), eval(EMul(EAdd(EInt(1), EInt(5)), EInt(2))))
    }

\end{minted}
All the tests are green. Nice.
In less than 20 lines of code we have working caclulator that can add and multiply arbitrary numbers.
\begin{minted}[]{kotlin}
interface Expression
data class EInt(val value:Int):Expression
data class EMul(val a:Expression, val b:Expression): Expression
data class EAdd(val a:Expression, val b:Expression): Expression

fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    if(expression is EMul){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value * right.value)
    }
    return expression
}

\end{minted}


\subsection{Sidenotes}
\label{sec:orgc3a2b7e}
\subsubsection{Moving evaluation into each expression}
\label{sec:org42d2d1b}
At this point all our evaluation is sitting within one \textbf{eval} function.
If we gonna add more expressions to the interpreter, amount of \textbf{if} statements will grow.
This can be avoided by extracting specific parts of the code, and moving them to expressions.
The result would look like this:
\begin{minted}[]{kotlin}
interface Expression{
    fun eval():Expression
}
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }
}

data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value + right.value)

    }
}
\end{minted}

It would require to change the test implementation as well.

\begin{minted}[]{kotlin}
 assertEquals(EInt(12), (EMul(EAdd(EInt(1), EInt(5)), EInt(2))).eval())

\end{minted}
\subsubsection{Simple optimisations}
\label{sec:orge2e1b94}
You might agree that multiplying anything by zero would not help a lot.
We can include it in our evaluation of \textbf{EMul}
\begin{minted}[]{kotlin}
data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return EInt(0)
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}
\end{minted}

And if you agree that integers are immutable values, we can avoid creating new copy of the EInt every time during the evaluation

\begin{minted}[]{kotlin}
val zeroInt = EInt(0)

data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return zeroInt
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}
\end{minted}
\section{The simplest parser you can think of}
\label{sec:org66ccf64}
To make the whole parsing easy, let us reiterate what problem are we trying to solve.
We need to take a string, and convert it to the expression.
It can be expressed in a test.
\begin{minted}[]{kotlin}
    @Test()
    fun testSimpleInt(){
        assertEquals(EInt(42), parse("42"))
    }
\end{minted}

As you might remember - we are lazy. So we will do something that would allow us to simplify things.
To use a library and a format a lot of people using now.
The most popular programming language of the century.
YAML.

\subsection{Parsing integers with yaml}
\label{sec:org7d01e69}
To make it work we would need to add dependency to the great \textbf{snakeyaml} library
\begin{minted}[]{kotlin}
dependencies {
    // https://mvnrepository.com/artifact/org.yaml/snakeyaml
    implementation("org.yaml:snakeyaml:1.32")

    testImplementation(kotlin("test"))
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.0")
}
\end{minted}

having such a useful tool makes our lives easy.

\begin{minted}[]{kotlin}
import org.yaml.snakeyaml.Yaml

fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return EInt(script as Int)
}
\end{minted}

We cannot parse anything but integers now, but at least our tests are green. Isn't that great?
\subsection{Expanding yaml expressions to support addition}
\label{sec:org717676f}
If you remember, our goal is to convert from strings to expressions as easy as possible.
To make it happen, the language we would use should be very similar to the expressions we have.

\begin{minted}[]{kotlin}
EAdd(EInt(3), EInt(5))
\end{minted}

might be represented in yaml as
\begin{minted}[]{yaml}
add
  - 3
  - 5
\end{minted}

And more complex expresison
\begin{minted}[]{kotlin}
EMul(EInt(10), EAdd(EInt(1), EInt(2)))
\end{minted}
Will have a form
\begin{minted}[]{yaml}
mul
  - 10
  - add
    - 1
    - 2
\end{minted}

Obviously this is good enough if we want to use it as part of yaml files.
But when you adding such an expression to the unit test, you would suffer.
Suffering should be optional, and to removing it we will utilise little known feature of Yaml, called \url{https://yaml.org/spec/1.2.2/\#chapter-7-flow-style-productions}

\begin{minted}[]{kotlin}
EAdd(EInt(3), EInt(5))
\end{minted}
becomes
\begin{minted}[]{yaml}
[add, 3, 5]
\end{minted}

and
\begin{minted}[]{kotlin}
EMul(EInt(10), EAdd(EInt(1), EInt(2)))
\end{minted}
is represented as

\begin{minted}[]{yaml}
[mul, 10, [add, 1, 2]]
\end{minted}
I kinda like it. It is shorter, and represents our internal structure pretty much
\subsection{parsing yaml with predefined expressions}
\label{sec:orga23c64f}
Test goes first
\begin{minted}[]{kotlin}
   @Test()
    fun testSimpleAdd(){
        assertEquals(EAdd(EInt(3), EInt(5)), parse("[add, 3, 5]"))
    }
\end{minted}

When \textbf{snakeyaml} parses flow-style expressions, it returns ArrayList.
So all we need to do is convert ArrayList to expression we want

\begin{minted}[]{kotlin}
fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):Expression{
   if(obj is Int){// if yaml loaded an integer -convert it to EInt
       return EInt(obj)
   }
    if(obj is ArrayList<*>){ // if we have arrayList
        val operation= obj[0] // we assume initial element is the name of operation
        if(operation == "add"){
            val left = convert(obj[1]) // converting first parameter of the operation
            val right = convert(obj[2]) // converting second parameter of the operation
            return EAdd(left, right)
        }
    }
    return EInt(-42) // since we don't have errors now, return something strange
}
\end{minted}

Essentially what we are doing here is very similar to the eval fucntion we defined previously.
Eval takes Expression as input and returns Integer values.
parse takes a string as an input and returns Expression.
Even conversion of addition look very similar. Pay attention to the recursive call in convert.

Of course if our source code would not have the structure we want, we will get very nasty errors.
But as was said previousy - let us focus on successful flow first, taking care of corner cases later.

Surprisingly enough, this implementation makes our test green.
Let's see if we try to parse more complicated expression.
\begin{minted}[]{kotlin}
    @Test
    fun testComplicatedAdd(){
        assertEquals(
            EAdd(EAdd(EInt(3), EInt(5)), EInt(42)),
            parse("[add, [add, 3,5], 42]"))
    }

\end{minted}

Green as well. Nice work!
\subsection{Adding multiplication to the mix}
\label{sec:org7a2db78}
Now we know what to expect, so we will add both tests from the beginning
\begin{minted}[]{kotlin}
    @Test
    fun testSimpleMultiplication(){
        assertEquals(EMul(EInt(11), EInt(33)), parse("[mul, 11, 33]"))
    }
    @Test
    fun testComplicatedMultiplication(){
        assertEquals(
            EMul(EMul(EInt(3), EInt(5)), EInt(42)),
            parse("[mul, [mul, 3,5], 42]"))
    }
\end{minted}

Implementation of parser is really simple. Nothing new under the sun.
\begin{minted}[]{kotlin}
fun convert(obj:Any):Expression{
    ...
    if(obj is ArrayList<*>){
        ...
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EMul(left, right)
        }
\end{minted}

We have a parser for addition, and we have a parser for multiplication.
Let's see how well they are working together.
\begin{minted}[]{kotlin}
    @Test
    fun testMulAndAdd(){
         assertEquals(
            EMul(EAdd(EInt(22), EInt(11)), EInt(44)),
            parse("[mul, [add, 22, 11], 44]"))
    }
\end{minted}

Tests are green. Feels great, isn't it?

\subsection{Evaluating parsed expressions}
\label{sec:org85c55d8}
Now we have both parth of the story. We can take a string and convert it to an expression.
We can take an expression and evaluate it.
Let us add some more tests would confirm this fact.
\begin{minted}[]{kotlin}
    @Test
    fun testComplicatedExpressionWithParsing() {
        assertEquals(EInt(10), (EMul(EMul(EInt(1), EInt(5)), EInt(2))).eval())
        assertEquals(EInt(10), parse("[mul, [mul, 1, 5], 2]").eval())
        assertEquals(EInt(12), (EMul(EAdd(EInt(1), EInt(5)), EInt(2))).eval())
        assertEquals(EInt(12), parse("[mul, [add, 1, 5], 2]").eval())
    }
\end{minted}

I specifically put original version here, so it is easy to compare complexity of expressions and amount of brackets.

\subsection{One more touch}
\label{sec:orga2bae4f}
If you look closely on the previous test, you might wondered, why did we use \textbf{EInt(10)} instead of just \textbf{10}? How hard would that be to make it happen?

Well, let's add one more operation, and call it \textbf{unparse}. It will take an expression and convert it to our yaml format. in such a way we will have the whole circle of life

Let us extend our expression interface with \textbf{unparse} method
\begin{minted}[]{kotlin}
interface Expression{
    fun eval():Expression
    fun unparse():String
}
\end{minted}

And expand our test cases for the parsing.
Make sure that unparsing parsed expression should give the same result
\begin{minted}[]{kotlin}

  @Test
    fun testSimpleIntUnparse(){
        assertEquals("42",EInt(42).unparse())
        assertEquals("42", parse("42").unparse())
    }

    @Test
    fun testSimpleAddUnparse(){
        val yaml = "[add, 3, 5]"
        assertEquals(yaml, EAdd(EInt(3), EInt(5)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testComplicatedAddUnparse(){
        val yaml = "[add, [add, 3, 5], 42]"
        assertEquals(
            yaml,
            EAdd(EAdd(EInt(3), EInt(5)), EInt(42)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testSimpleMultiplicationUnparse(){
        val yaml = "[mul, 11, 33]"

        assertEquals(yaml, EMul(EInt(11), EInt(33)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testComplicatedMultiplicationUnparse(){
        val yaml = "[mul, [mul, 3, 5], 42]"
        assertEquals(
            yaml,
            EMul(EMul(EInt(3), EInt(5)), EInt(42)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testMulAndAddUnparse(){
        val yaml = "[mul, [add, 22, 11], 44]"
        assertEquals(
            yaml,
            EMul(EAdd(EInt(22), EInt(11)), EInt(44)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }

\end{minted}

Remember, the more tests you have, the less corner cases you should worry about.

implementation is straightforward.

\begin{minted}[]{kotlin}
data class EInt(val value:Int):Expression {
    ...
    override fun unparse(): String {
        return value.toString()
    }
}

data class EMul(val a:Expression, val b:Expression): Expression {
    ...
    override fun unparse(): String {
        return "[mul, ${a.unparse()}, ${b.unparse()}]".format()
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    ...
    override fun unparse(): String {
        return "[add, ${a.unparse()}, ${b.unparse()}]"
    }
}
\end{minted}
As expected, tests are passing.
\subsection{Evaluating parsed expressions}
\label{sec:org4f57534}
We took some detour to make the basics work. Now we know how to read yaml, interpret the contents of the yaml using intermediate representation, and save results back to the yaml. Which in turn can be read, interpreted and saved to yaml.

But what is missing is some tests that confirm that our assumptions are correct.
\begin{minted}[]{kotlin}
 @Test
    fun testSimpleIntegerWithParsing() {
        assertEquals(EInt(5), parse("5").eval())
        assertEquals(EInt(-5),parse("-5").eval())
        assertEquals(EInt(0), parse("0").eval())
    }

    @Test
    fun testSimpleAdditionWithParsing() {
        assertEquals(EInt(5), parse("[add, 5, 0]").eval())
        assertEquals(EInt(5), parse("[add, 0, 5]").eval())
        assertEquals(EInt(10),parse("[add, 7, 3]").eval())
        assertEquals(EInt(7), parse("[add, -3, 10]").eval())
        assertEquals(EInt(6), parse("[add, 10, -4]").eval())
    }

    @Test
    fun testComplexAdditionWithParsing() {
        assertEquals(EInt(6),  parse("[add, 1, [add, 2,3]]").eval())
    }

    @Test
    fun testSimpleMultiplicationWithParsing() {
        assertEquals(EInt(0), parse("[mul, 0, 42]").eval())
        assertEquals(EInt(0), parse("[mul, 42, 0]").eval())
        assertEquals(EInt(42),parse("[mul, 1, 42]").eval())
        assertEquals(EInt(42), parse("[mul, 42, 1]").eval())
        assertEquals(EInt(4), parse("[mul, 2, 2]").eval())
    }

    @Test
    fun testComplicatedMultiplicationWithParsing() {
        assertEquals(EInt(10), parse("[mul, 1, [mul, 5, 2]]").eval())
        assertEquals(EInt(12), parse("[mul, 2, [add, 5, 1]]").eval())

        assertEquals("10", parse("[mul, 1, [mul, 5, 2]]").eval().unparse())
        assertEquals("12", parse("[mul, 2, [add, 5, 1]]").eval().unparse())
    }
\end{minted}

In the last test you can see all the parts working together.
And as you might have guessed, our tests are passing.
\subsection{Food for thought}
\label{sec:orgf979707}
Parsing plays important role in the whole evaluation process. While we simplified it to the minimum, we still can improve it.

For example - we have duplication while parsing addition and multiplication operations.
One way to make it better would be to add support to binary arithmetical operations.
But that would come at the cost of complicating our abstract syntax tree. As usual in the computer science - you cannot remove the complexity. You can just move it in some other place.

Here's another puzzle for you. What should this expression be parsed into?
\begin{minted}[]{kotlin}
[mul, 0, [add, 11, 42]]
\end{minted}

One might argue it is obvious - result is
\begin{minted}[]{kotlin}
EMul(EInt(0), EAdd(EInt(11), EInt(42)))
\end{minted}

But equally good option is
\begin{minted}[]{kotlin}
EInt(0)
\end{minted}

Since we know that multiplication by zero would give us zero in the end, why bother creating complex expression?
And as in previous example - we are simplifiying evaluation by complicating parsing.
You cannot remove the complexity. You can just push it somewhere else.
\subsection{Reflecting and Wrapping up}
\label{sec:org495c7a3}
It took some time and turns to get to this point.
A lot of text, and a lot of explanations. But try to look at it from the different perspective.
our parser is 26 lines long, and our interpreter is just 42 lines long.
In less than 100 lines we have fully functional interpreter, that can deal with complex math expressions.
And load and save expressions to yaml.

Let's look at our code in its full glory.
\begin{minted}[]{kotlin}
// Domain.kt
interface Expression{
    fun eval():Expression
    fun unparse():String
}
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}

val zeroInt = EInt(0)
data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return zeroInt
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }

    override fun unparse(): String {
        return "[mul, ${a.unparse()}, ${b.unparse()}]".format()
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value + right.value)

    }

    override fun unparse(): String {
        return "[add, ${a.unparse()}, ${b.unparse()}]"
    }
}
// Parser.kt
import org.yaml.snakeyaml.Yaml

fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):Expression{
   if(obj is Int){
       return EInt(obj)
   }
    if(obj is ArrayList<*>){
        val operation= obj[0]
        if(operation == "add"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EAdd(left, right)
        }
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EMul(left, right)
        }
    }
    return EInt(-42)
}
\end{minted}
\section{Core language, host language and a lot of sugar}
\label{sec:org72d50bb}
When implementing and interpreter you want to have ability to define new type of capabilites.
At the same time you don't want to spend too much time refactoring base implementation.
Changing Ast and tests for it, implementations, is very time consuming process.
\subsection{core, host, sugared}
\label{sec:org3ec09ea}
This can be avoided by introducing new level of abstration. As you know, you can solve every problem in IT by adding an additional level of abstraction.
Let's call our arimetic language we have the core language. It is core of our interpreter, and we don't want to expose its internal for the customers.
We would like to keep it as small as possible, so all refatoring and optimisations would have smaller blast radius.
As for ease of use we can create new expressions, which we would call sugared expressions.
They will be used as our interface, and should be converted to the core language to be interpreted
\subsection{Adding sugar}
\label{sec:org3362ad7}
Let's say we want to add new operation to the mix \textbf{sub}, which stands for the substraction.
how would it fit to our idea of sugared language?
\begin{minted}[]{kotlin}
interface SugarExpression{
    fun desugar():Expression
}

data class SugarInt(val v:Int):SugarExpression{
    override fun desugar(): Expression {
        return EInt(v)
    }
}

data class SugarAdd(val left:SugarExpression, val right:SugarExpression) : SugarExpression{
    override fun desugar(): Expression {
       return EAdd(left.desugar(), right.desugar())
    }

}

data class SugarMul(val left:SugarExpression, val right:SugarExpression): SugarExpression{
    override fun desugar(): Expression {
       return EMul(left.desugar(), right.desugar())
    }
}
\end{minted}
Now it is pretty much replicating what with had with the usual expression.
Main difference might be that we don't evaluate anything here. We're just converting Sugared expression to our core expressions.

\subsubsection{Defining substraction}
\label{sec:orgb338995}
Now we can extend our sugared languge with substraction function.
\begin{minted}[]{kotlin}

// Take a closer look at this method
data class SugarSub(val left:SugarExpression, val right: SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EAdd(left.desugar(),  EMul(EInt(-1), right.desugar() ))
    }
}
\end{minted}

Just have a look.
We don't have substraction at our core language. But our customers might never know about it.
For what they care, they can call \textbf{sub} function, and it would return the expected result to them.
Isnt' that nice?

But sharp-eyed reader might notice, that this implemantation would not work.
Our parser returns Expressions, not SugarExpressions. We need to change that.
And add few more unit tests to the mix.

our parser looks like this now
\begin{minted}[]{kotlin}
import org.yaml.snakeyaml.Yaml

fun parse(input:String):SugarExpression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):SugarExpression{
   if(obj is Int){
       return SugarInt(obj)
   }
    if(obj is ArrayList<*>){
        val operation= obj[0]
        if(operation == "add"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarAdd(left, right)
        }
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarMul(left, right)
        }
        if(operation =="sub"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarSub(left, right)
        }
    }
    return SugarInt(-42)
}
\end{minted}

our tests should be changed in quite a few places. For example, parsing should be updated
\begin{minted}[]{kotlin}
 @Test
    fun testComplicatedMultiplicationUnparse(){
        val yaml = "[mul, [mul, 3, 5], 42]"
        assertEquals(
            yaml,
            SugarMul(SugarMul(SugarInt(3), SugarInt(5)), SugarInt(42)).desugar().unparse())
        assertEquals(yaml, parse(yaml).desugar().unparse())
    }
    @Test
    fun testMulAndAddUnparse(){
        val yaml = "[mul, [add, 22, 11], 44]"
        assertEquals(
            yaml,
            SugarMul(SugarAdd(SugarInt(22), SugarInt(11)), SugarInt(44)).desugar().unparse())
        assertEquals(yaml, parse(yaml).desugar().unparse())
    }
\end{minted}
Do you see this beatuful pattern of parse -> desugar -> unparse

Of course, evaluation tests should be changed as well
\begin{minted}[]{kotlin}
 @Test
    fun testComplicatedMultiplicationWithParsing() {
        assertEquals(EInt(10), parse("[mul, 1, [mul, 5, 2]]").desugar().eval())
        assertEquals(EInt(12), parse("[mul, 2, [add, 5, 1]]").desugar().eval())

        assertEquals("10", parse("[mul, 1, [mul, 5, 2]]").desugar().eval().unparse())
        assertEquals("12", parse("[mul, 2, [add, 5, 1]]").desugar().eval().unparse())
    }
\end{minted}

they follow the same pattern more or less. parse -> desugar -> eval -> unparse

Now that our little refactoring is done, we are in a good shape to add test for our substraction.

\begin{minted}[]{kotlin}
    @Test
    fun testMulAndSubUnparse(){

        val yaml = "[mul, [sub, 22, 11], 44]"
        val desugared = "[mul, [add, [mul, -1, 22], 11], 44]"
        assertEquals(
            desugared,
            SugarMul(SugarSub(SugarInt(22), SugarInt(11)), SugarInt(44)).desugar().unparse())
        assertEquals(desugared, parse(yaml).desugar().unparse())
    }
\end{minted}

It is a good idea to test that evaluation of substraciton works as well.

\begin{minted}[]{kotlin}
    @Test
    fun testMulAndSubEvaluationWithParsing(){
        val yaml = "[mul, [sub, 22, 11], 44]"
        assertEquals("484", parse(yaml).desugar().eval().unparse())
    }
\end{minted}

We've just expanded our language with one more built-in function, wihout touching the core interpretation logic. And whast is even more interesting - the result of evaluation is correct.
\subsection{Adding negation operation}
\label{sec:orga0f50f0}
Now we can expand our primitive list by adding operation \textbf{neg} which should change the sight of the operation.

Since we're working with the sugared operations, we can approach to this having this definition
\begin{minted}[]{kotlin}
data class SugarNeg(val value:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EMul(EInt(-1), value.desugar())
    }

}
\end{minted}

Or we might go other way around.

\begin{minted}[]{kotlin}
data class SugarNeg2(val value:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return SugarSub(SugarSub(value, value), value).desugar()
    }

}
\end{minted}

Second one would not be the most efficient implementation, but would reduce our dependency on the core language. As you might see there's no core language structures besides \textbf{Expression} as return value.

This is a great example of flexibility sugaring and desugaring brings to the table.

If we implemented negation first, we might change our implementation of \textbf{sub} as well.
\begin{minted}[]{kotlin}
data class SugarSub2(val left:SugarExpression, val right:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EAdd(SugarNeg(left).desugar(), right.desugar())
    }
}
\end{minted}

As you can see, sugaring gives a lot of flexibility towards how our functions are implemented.

Let's finish our negation by adding some tests and parsing bits.
\begin{minted}[]{kotlin}
        if(operation =="neg"){
            val value = convert(obj[1])
            return SugarNeg(value)
        }
\end{minted}

and test cases for the parsing
\begin{minted}[]{kotlin}
    @Test
    fun testNegUnparse()
    {
        val yaml = "[neg, [mul, 2, 10]]"
        val desugared = "[mul, -1, [mul, 2, 10]]"
        assertEquals(desugared, SugarNeg(SugarMul(SugarInt(2), SugarInt(10))).desugar().unparse())
        assertEquals(desugared, parse(yaml).desugar().unparse())
    }
\end{minted}

and for the evaluation as well
\begin{minted}[]{kotlin}
    @Test
    fun testNegationEvaluation(){
        val yaml = "[neg, [mul, [sub, 22, 11], 44]]"
        assertEquals("-484", parse(yaml).desugar().eval().unparse())
    }
\end{minted}

Remember, there's no such thing as too many tests, if they all make sense.


We will get back to the sugaring concept later. It is very powerful idea worth revisiting.

\subsection{Food for thought}
\label{sec:org6802366}
\begin{itemize}
\item You want to add \textbf{uminus} operation, which is operates exactly like negation, but has different representation in yaml syntax.
\begin{minted}[]{yaml}
[uminus, [mul, [sub, 22, 11]], 44]
\end{minted}
Can you think of a way to make this evaluation possible touching only parsing?
\end{itemize}

\section{Adding primitive functions to the language}
\label{sec:org3372292}
Now that we know how to add new functions as part of our sugaring process, we might ask ourselves :
``Is it possible to define new functions without touching the host language''?
Now every new defined function should have some correspondence in Kotlin.
It would be nice to make it happen in yaml directly.

Let's come up with the syntax for the function definition.
It might have a lot of different flavors, but all of them should take care of few elements
\begin{enumerate}
\item keyword for function definition
\item function name
\item function arguments
\item body of the function
\end{enumerate}

We can start with the double function
\begin{minted}[]{yaml}
fun   # keyword for the function definition
 - [double, x]  # function name and arguments
 - [add, x, x]  # body of the function
\end{minted}

Of course short version would be preferrable for unit tests.
\begin{minted}[]{yaml}
[fun, [double, x], [add, x, x]]
\end{minted}

After defining \textbf{double} function, it is really tempting to introduce \textbf{quad} function

\begin{minted}[]{yaml}
[fun, [quad, x], [double, [double, x]]]
\end{minted}
functions should be able to call one another, otherwise what is the point in defining them?


Functions without parameters should also be possible.

\begin{minted}[]{yaml}
[fun, [const42], 42]
\end{minted}

We will work with functions having single argument for now, and will deal with multiple arguments representation little bit later.

\subsection{Dealing with function and argument names}
\label{sec:org6d4d7dd}
Now we have a good understanding how our function definitions would look like in yaml, let's think about how we gonna represent them in Kotlin.

Before we start implementing anyting, we need to decide, how we can represent function and variables names.

\begin{minted}[]{yaml}
[fun, [double, x], [add, x, x]]
\end{minted}

When looking into this expression from yaml perspective `x` and `double` will be represented as strings.
But semantically they should be different. They should represent some identifier, or a symbol if you wish.

Therefore we need to expand our parser to support symbols.

\begin{minted}[]{kotlin}
data class ESymbol(val value:String):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value
    }
}

\end{minted}

Here how our representation would look like
\begin{minted}[]{kotlin}
data class EFunDef(val name:ESymbol, val argument:ESymbol, val body:Expression):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return "[fun, [${name.unparse()}, ${argument.unparse()}], ${body.unparse()}]"
    }
}

\end{minted}

Function definition is evaluated to itself. It is just a delcaration of the function, it doesn't do anything at all.

To make a function call, we need to have different structure. In some places it is called \textbf{function application}, i would use \textbf{function call}, since it is less academic and more commonly used
\begin{minted}[]{kotlin}
data class EFunCall(val name:ESymbol, val argument:Expression):Expression{
    override fun eval(): Expression {
        TODO("Not yet implemented")
    }

    override fun unparse(): String {
        return "[${name.unparse()}, ${argument.unparse()}]"
    }

}
\end{minted}

We dont' know exactly how evaluation will work, but we can alreade expand our parser to support both function definitions and function calls.
\subsection{Expanding parser for function definitions and calls}
\label{sec:org8d2ad9a}
When we are starting new implementation, and not totally sure what expected result is, we write tests.
Parsing function definition looks like a good point.


\section{Pros and cons of sugaring}
\label{sec:org61c1dd2}
\subsection{performance hit}
\label{sec:org57d9643}
\subsection{simplified runtime}
\label{sec:orgfc00f36}
\subsection{Haskell core language}
\label{sec:org9da2da1}
\subsection{targeting degugaring}
\label{sec:orgd118191}
\subsection{WebAssembly desugar}
\label{sec:orga868b36}
\subsection{python desugar}
\label{sec:org427551c}

\section{Errors and strange things}
\label{sec:org8448893}
\subsection{adding division}
\label{sec:org4590eba}
\subsection{what should happen if we divide by zero?}
\label{sec:org14af7ae}
\subsection{It's all about environment}
\label{sec:orgd461d19}
\section{Defining variables for fun and profit}
\label{sec:orge09c864}
While working with the expressions, it might be useful to have some variables.
for example, ability to compute something like this:
\begin{minted}[]{yaml}
[mul, x, 3]
\end{minted}
To make it happen, we need to do some preparations.
First of all, we need to understand what `x` means during parsing.
Secondly, we should take the value attached to `x` from somewhere.

If we try to use default yaml parser, it will say that `x` is represented as a string.
And while we are not working with strings in our language at the moment, we definitely will be in the future.
So during parsing we shall convert this string to some new type of the data.
Something that can be treated as identifier or variable name. Let's call it a symbol

\begin{minted}[]{kotlin}
data class ESymbol(val value:String):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value
    }
}

data class SugarSymbol(val name:String):SugarExpression{
    override fun desugar(): Expression {
       return ESymbol(name)
    }

}
\end{minted}
Here's an example how it should work
\begin{minted}[]{kotlin}
    @Test
    fun testOperationWithSymbol(){
        assertEquals(SugarAdd(SugarSymbol("x"), SugarInt(5)),
                     parse("[add, x, 5]"))

        assertEquals(SugarAdd(SugarSymbol("x"), SugarSymbol("y")),
                     parse("[add, x, y]"))

        assertEquals(SugarAdd(
                         SugarAdd(SugarSymbol("x"), SugarSymbol("y")),
                        SugarSymbol("z")),
            parse("[add, [add, x, y], z]"))

    }
\end{minted}
Now we have a way to introduce variables to the expressions, but how are we planning to evaluate them?
Which brings us to the next question
\subsection{Where do our variables live?}
\label{sec:org0f5f807}
Variables should be defined somewhere. There should be a binding between symbol, and the value that symbol represents.

The easiest way to make this mapping would be a dictionary. Or a hashmap if you like.

\begin{minted}[]{kotlin}
data class Environment(val bindings:HashMap<ESymbol, Expression>){
    fun addBinding( name:ESymbol,  value:Expression){
        bindings[name] = value
    }
    fun isDefined(name:ESymbol): Boolean{
        return bindings.containsKey(name)
    }
    fun get(name:ESymbol):Expression{
        return bindings[name]!!
    }
}
\end{minted}
As you can see we are assuming that we use core language as part of bindings.
Since our evaluation process works on the core language, not the sugared one, this is very logical thing to do.

Test cases are following:

\begin{minted}[]{kotlin}

    @Test
    fun isDefined() {
        val env = Environment(hashMapOf())
        assertFalse(env.isDefined(ESymbol("x")))
        val env2 = Environment(hashMapOf( Pair(ESymbol("x"), EInt(5))))
        assertTrue(env2.isDefined(ESymbol("x")))
    }
    @Test
    fun addBinding() {
        val env = Environment(hashMapOf())
        env.addBinding(ESymbol("x"), EInt(5))
        assertTrue(env.isDefined(ESymbol("x")))
        assertEquals(EInt(5), env.bindings[ESymbol("x")])
        assertEquals(EInt(5), env.get(ESymbol("x")))

    }
\end{minted}

What would happen if you try to get the variable that is not defined in the environment?
You will get a runtime error of course. Error handling will be taken care of later. I promise :)
Let us focus on well-behaving programs, where nothing strange happens.

\subsection{Using environment in the evaluation}
\label{sec:org595a314}
We know how to define variable, and bind values to them.
But it wont' be useful until we can attach this environment to our evaluation.
\begin{minted}[]{yaml}
## somewhere out here we should have an environmet with defined 'x'
[add, x, 5]
\end{minted}

The only place where we can plug it in is our \textbf{eval} function.
Time for the improvement

Remeber our \textbf{Expression} interface from very long time ago?
\begin{minted}[]{kotlin}
interface Expression{
    fun eval():Expression
    fun unparse():String
}
\end{minted}

We will tweak it a little bit

\begin{minted}[]{kotlin}
interface Expression{
    fun eval(env:Environment):Expression
    fun unparse():String
}
\end{minted}

We're claiming here that evaluation cannot happen in vacuum. We need to take into account an environment we're in.
Sometimes it might be an empty environment, somethimes it might be full of variable definitions.

This is a small step for our interface, but a huge impact for our interpreter.
It breaks all our evaluation implementations.
It breaks all our evaluation tests.
Good news is that we have tests, so we know what is broken.
What else can be done rather than fixing it?

\subsection{Fixing evaluation with environment}
\label{sec:org26b85e2}
Our first case is really simple one.
\begin{minted}[]{kotlin}
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }
   ...
}
\end{minted}

How shall we interpret integer values if they live in some environment?
Easy. Integers are always integers, so we can simply ignore the environment.

\begin{minted}[]{kotlin}
data class EInt(val value:Int):Expression {
    override fun eval(env:Environment): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}
\end{minted}

Done.

With addition and multiplication it would be not as straighforward.

Let's stop and think for a moment.
What we would like to happen when we have an expression defined within environment?
\begin{minted}[]{yaml}
## env: {x = 5}
[add, x, 10]
\end{minted}

I would say it should be converted to
\begin{minted}[]{yaml}
[add, 5, 10]
\end{minted}
We don't care about the variable name. We care only about value attached to it. Its binding.

Having variable name, variable definition and expression where this variable exists, we want to substitute variable with its value.

\begin{minted}[]{kotlin}
fun substitute(variableName:ESymbol), env:Environment, expession:Expression): Expression
\end{minted}

If you're thinking this function should be part of the \textbf{Expression} interface, in tend to agree with you.

Our poor \textbf{Expression} is getting bigger and bigger, but it is a good things.

\begin{minted}[]{kotlin}
interface Expression{
    fun eval(env:Environment):Expression
    fun substitute(symbol:ESymbol, env:Environment):Environment
    fun unparse():String
}
\end{minted}

Now it breaks even more things in our code. But this is the price we need to pay.

\begin{minted}[]{kotlin}
data class EInt(val value:Int):Expression {
    override fun eval(env:Environment): Expression {
        return this
    }

    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}
\end{minted}

for integers substituion is as easy as it gets.
We are just ignoring all the symbols and environment.

Let's see what we can do with \textbf{ESymbol}.
\begin{minted}[]{kotlin}
data class ESymbol(val name:String):Expression{
    ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){
            return env.get(symbol)
        }
        return this
    }
   ...
}
\end{minted}

if we are trying to substitue symbol, and it is definted in the environment, we will return record from the variable.

It might sound little bit confusing so here are few examples.

\begin{minted}[]{yaml}
# env: {x = 5}
x
\end{minted}

should be transformed to

\begin{minted}[]{yaml}
5
\end{minted}

And if variable is not bound in the environment
\begin{minted}[]{yaml}
# env: {x = 5}
y
\end{minted}

should remain untouched
\begin{minted}[]{yaml}
y
\end{minted}


Now that we've done with substitution for the symbols, addition and multiplication should be simple enough.

\begin{minted}[]{kotlin}
data class EAdd(val a:Expression, val b:Expression): Expression {
   ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return EAdd(a.substitute(symbol, env), b.substitute(symbol,env))
    }
   ...
}

data class EMul(val a:Expression, val b:Expression): Expression {
    ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return EMul(a.substitute(symbol, env), b.substitute(symbol, env))
    }
   ...
}

\end{minted}

As usual, our tests would show us an example what we expect to happen, and how the variable substitution should look like.

\begin{minted}[]{kotlin}
 @Test
    fun testSubstitution(){
        val env1 = Environment(hashMapOf(Pair(ESymbol("x"), EInt(5))))
        assertEquals(EInt(5), ESymbol("x").substitute(ESymbol("x"), env1))
        assertEquals(ESymbol("y"), ESymbol("y").substitute(ESymbol("x"), env1))

        assertEquals("[add, 5, 5]",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())

        assertEquals("[mul, 5, 5]",
            parse("[mul, x, x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())

        assertEquals("[add, [mul, 5, 5], 5]",
            parse("[add, [mul, x, x], x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())


        val env2 = Environment(hashMapOf(Pair(ESymbol("x"), EInt(5)),
            Pair(ESymbol("y"), EInt(7))))
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2).unparse())


        assertEquals("[add, [mul, 5, 7], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .substitute(ESymbol("y"), env2)
                .unparse())

        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[mul, 11, [add, [add, 3, 4], 11]]").desugar())))

        assertEquals("[add, [mul, 11, [add, [add, 3, 4], 11]], [mul, 11, [add, [add, 3, 4], 11]]]",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .unparse()
            )
    }
\end{minted}
As you can see, substitutions can be as complex as we want them to be.
Now it is good time to do something about evaluation.
\subsection{improving taking into account the variables.}
\label{sec:org3b58605}
At this point we know how to substitute variables, and we also know how to evaluate expressions.
So mixing these two together we will get the evaluation process.
\begin{minted}[]{kotlin}
        assertEquals("10",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1).unparse())

        assertEquals("25",
            parse("[mul, x, x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1)
                .unparse())

        assertEquals("30",
            parse("[add, [mul, x, x], x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1)
                .unparse())

\end{minted}
these examples would work, evaluation is simple and straghtforward

\begin{minted}[]{kotlin}
        assertEquals("[add, [mul, 5, y], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .eval(env1)
                .unparse())

\end{minted}
and this will error out.
Because we cannot evaluate the symbol ' y'

As you can see for the evaluation it is really important to substitute all the variables before we do the evaluation. Otherwise we would get as what is know as 'variable not found' exception.

this is easily fixable. We just need to substitute 'y' as well
\begin{minted}[]{kotlin}
        assertEquals("[add, [mul, 5, y], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .substitute(ESymbol("y"), env2)
                .eval(env1)
                .unparse())
\end{minted}

Now it is green.

In you looked carefully, you might see that substitution uses env2 for both variables, while evaluation uses 'env1'. This shows us flexibility the interpreter shows. But at the same time it reminds us how careful we should be about passing the correct environment.

Some might ask - why do we need to pass environment during the substitugion phase?
Can't it be taken from the environment during the evaluation phase?
Very good question. It could  be done that way, but you well need to do foreach replacement for every variable in the environment. While the expression itself might use only oe or two of them. Or manybe none at all.

\subsection{What if our variables are more complex than simple constants?}
\label{sec:org674283c}
Prevously our values for 'x' and 'y' were simple constants. But what if we want them to be expressions?
What needs to be changed, and how much effort would it require to make evaluation aware of more complicated expressions?

Let us start with the simple one
\begin{minted}[]{yaml}
# env : {x = [add, 40,2]}
[add, x, x]
\end{minted}

Actually we have several options
We can substitute the value, or we can evaluate the value.

Substitution example we've seen previously.
\begin{minted}[]{kotlin}
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

    // we are replacing 'x' with the expression it is bound to
        assertEquals("[add, [add, 10, 33], [add, 10, 33]]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

        // and then we can do the evaluation
        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
\end{minted}

Upside of this approach is that is straightforward. You know exaclty what is happening and why it is happening by just looking on the expression.

But we can do something more interesting here.
What if we evaluates 'x' before we do the substitution?
after all, we know how to evaluate expresisons. And 'x' is an expresison in this scenario.
Why not just do it?

For that we would need to change our substitution function for the symbol
currently it looks like this
\begin{minted}[]{kotlin}
data class ESymbol(val name:String):Expression{

   // ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        // we are just looking for the symbol in the environment
        if(symbol.name == name){
            return env.get(symbol)
        }
        return this
    }
    // ...

}

\end{minted}

Now instead of simply getting symbol value from environment we are evaluating it first.

\begin{minted}[]{kotlin}
data class ESymbol(val name:String):Expression{

 // ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){
            // this part remains the same, getting value out of env
            val initialExpression = env.get(symbol)

            // evaluating the symbol in the same environment
            val evaluated = initialExpression.eval(env)

            // saving evaluated expression back to the environment
            env.bindings[symbol] = evaluated

            return evaluated
        }
        return this
    }
    // ...

}
\end{minted}

Unfortunately, our test will be broken now and will fail with the following exception
\begin{minted}[]{kotlin}
       val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("[add, [add, 10, 33], [add, 10, 33]]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

Expected :[add, [add, 10, 33], [add, 10, 33]]
Actual   :[add, 43, 43]
\end{minted}

Any ideas why it happened?
Of course, previously we were substituting the 'x' with explicit value '[add, 10, 33]'.
And now we are replacing it with the computed value '43' in this case.

Adjusted unit test would look like this

\begin{minted}[]{kotlin}
    @Test
    fun testComplicatedExpression(){
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("[add, 43, 43]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
    }
\end{minted}

What else has changed?
Well now we are more computationally efficient: 'x' is calculated only once, during the substitution phase.

We can go even further - add flag 'computed' to the symbol, so we don't call 'evaluate' more than once.

\begin{minted}[]{kotlin}
 data class ESymbol(val name:String):Expression{
// we've added the evaluated flag to know if this symbol has been already evaluated
     var evaluated = false

    override fun eval(env: Environment): Expression {
        return this
    }

    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){

            val initialExpression = env.get(symbol)
            // if it has been evaluated, we just return the result
            if(this.evaluated){
                return initialExpression
            }

            // otherwise we are executing the evaluation
            val evaluatedSymbol = initialExpression.eval(env)

            // save the result in the environment
            env.bindings[symbol] = evaluatedSymbol
            // and updateing the evaluated flag
            this.evaluated = true
            return evaluatedSymbol
        }
        return this
    }

    override fun unparse(): String {
        return name
    }
}
\end{minted}

No matter how many times 'x' will be referenced during the calculations it will be calculated only once.
This fact remains true for any variable we are substituting in the expression.

Let's look at our test one more time.
Can we improve something here?
\begin{minted}[]{kotlin}
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
\end{minted}

We are calling `substitute` before the evaluting expression.
Which is fine, but can we do this substitution right inside of evaluation?
After all symbol knows how to substitute itself given the environment?

What if we do somehting like this:

\begin{minted}[]{kotlin}
 data class ESymbol(val name:String):Expression{
     var evaluated = false

    override fun eval(env: Environment): Expression {
        // now instead of returning the symbol itself
        // we're returning the substitution of it
        // this means every symbol is evaluated only once.

        return substitute(this, env)
        // return this;
    }

\end{minted}

And now the test might be simplified a little bit
\begin{minted}[]{kotlin}
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("86",
            parse("[add, x, x]").desugar()
            // substitution would still work
            // and provide the same result
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())


        assertEquals("86",
            parse("[add, x, x]").desugar()
                // passing complex environmet to the expression
                // no need to substitute manually
                .eval(complexEnv)
                .unparse())
\end{minted}


let's change the evironment and see if our result changes as well.

\begin{minted}[]{kotlin}
    @Test
    fun testingSameExpressionDifferentEnvironment(){
        val firstEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        val firstExpression=parse("[add, x, x]").desugar()

        assertEquals("86",
            firstExpression
                .eval(firstEnv)
                .unparse())

        val secondEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 20, 11]").desugar())))
        val secondExpression=parse("[add, x, x]").desugar()
        assertEquals("62",
            secondExpression
                .eval(secondEnv)
                .unparse())

    }
\end{minted}

We have two indentical expressions `[add, x, x]`
and their evaluation results changes if we change the environment.
Now our programs has become way more generic. Defining variables and evaluating them in differnt contexts is extremely powerful tool.
We will use to work with functions. But not's let get ahead of ourselves.

What whould happen if we use single expression in both tests?
would it work? Any guesses?
\begin{minted}[]{kotlin}
    @Test
    fun testingExactlySameExpressionDifferentEnvironment(){
        val firstEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        val expression=parse("[add, x, x]").desugar()

        assertEquals("86",
            expression
                .eval(firstEnv)
                .unparse())

        val secondEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 20, 11]").desugar())))
        assertEquals("62",
            expression
                .eval(secondEnv)
                .unparse())

    }
\end{minted}

Almost the same example. But now we have one expression evaluated in two different environments.
And it fails on the second one with very strange error.

\begin{minted}[]{kotlin}
java.lang.ClassCastException: class EAdd cannot be cast to class EInt (EAdd and EInt are in unnamed module of loader 'app')

	at EAdd.eval(Domain.kt:44)
\end{minted}

Why is that? How come that seemingly indentical tests behave differently?

Maybe it depends on the environment itself? But no.
If we change the place of `firstEnv` and `secondEnv` we would still get the same error.

Something fishy is going on here. Let's have a closer look
\subsection{Mutalbe vs immutable variables}
\label{sec:org0b292a4}
\section{Adding variables to the mix}
\label{sec:orge396963}
\subsection{should variables have a type?}
\label{sec:orgd333fbf}
\subsection{adding environment to our expressions}
\label{sec:orgc46eef3}
\subsection{if you change the environment, expression changes as well.}
\label{sec:org464f2b7}
\subsection{adding string support to the language}
\label{sec:org7d572cc}

\subsection{powers, exponents, mods and so on}
\label{sec:org109b740}
\section{Evaluating parameters of the funciton. Order matters}
\label{sec:orgb4cb22f}
\subsection{lazy vs eager evaluation. Pros, cons, implementation}
\label{sec:org5641765}
\section{Adding functions to the language.}
\label{sec:org394aa11}
\subsection{function definition syntax}
\label{sec:org464fbfe}
\subsection{function calls syntax}
\label{sec:org8cf8175}
\subsection{What should happen if you define function within the function?}
\label{sec:org94e6e38}
\subsection{What should happen if you call function within the function?}
\label{sec:orgde9c989}
\subsection{Few words on recursive calls}
\label{sec:org8a18ad5}
\section{Adding conditional expressions}
\label{sec:org3f2d5b8}
\subsection{adding boolean expression to the language}
\label{sec:orgcaee647}
\subsection{adding IFs to the mix}
\label{sec:orgf388edd}
\subsection{control flow is not as straighforward as you might think of it}
\label{sec:org71d95ed}
\section{Adding lists to the language}
\label{sec:org9f23cfc}
\subsection{how generic is your generic?}
\label{sec:org7335e3b}
\subsection{how generic is your function?}
\label{sec:org60a2d9f}
\subsection{adding foreach}
\label{sec:orgcee5b47}
\subsection{adding list comprehension}
\label{sec:org0c3bda0}
\section{Typing and optimisation. part 2}
\label{sec:orgffd028d}
\section{Something about evaluation speed}
\label{sec:org136025c}

\subsection{environments again}
\label{sec:org1bf95c1}
\subsection{tail call optimisation}
\label{sec:org4259604}
\subsection{JZ, JNZ, JMP, Lisp \& WebAssembly}
\label{sec:orgec1139a}
\section{Adding types to the language}
\label{sec:org2169e3e}
\subsection{number vs float vs int32 vs int64}
\label{sec:org1590b72}
\subsection{function should know about types as well}
\label{sec:orgeb694f2}
\section{Minimal required type theory}
\label{sec:org0d0012b}
\subsection{Why golang avoided generics for so long}
\label{sec:org4835ac1}
\subsection{How to read typing expressions}
\label{sec:org9047e3a}
\section{type inferencing  the language. Simple version}
\label{sec:org6368c1d}
\section{Generating WebAssembly for fun and profit}
\label{sec:orgcee79c4}
\section{Generating JVM based things for fun and profit}
\label{sec:orga848367}
\section{type inferencing on steroids}
\label{sec:org78bbfaa}
\subsection{How haskell, scala and friends work under the hood}
\label{sec:org85df50d}
\end{document}
