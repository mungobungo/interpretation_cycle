#+title: Interpretation for lazy and curious
* Interpretation. part 1
The core functionality of interpreters might be distilled to two steps.
1) Parse source code to some internal representation
2) Evaluate the internal representation, so it will be reduced to the result we need.
Here I will do my best to skip as much as possible of the first one.
You dont' need to know quantum physics to be able to swim.

** Can you do it?
When talking about interpretation  most of the people start thinking about complex things.
register allocation, memory management, grammars and DFAs.
I will try to keep it simple.
As simple as possible without loosing core of the essence.
Let's assume you have a yaml file
#+begin_src yaml
bold
- some text
- and more text
#+end_src

How hard would that be to transform this yaml to the html?
#+begin_src html
<b>
  <p>some text</p>
  <p> and more text></p>
</b>
#+end_src

My guess would be that majority of the developers won't have troubles with doing so.
We're just transforming on tree structure to another tree structure.

And this is the essense of interpretation. We're taking one tree structure and converting it to another tree structure.
If you can convert yaml to html, you're good to go.
* Parsing and other friends
Most of the compilers and interpreters books start with parsing.
You neeed to investigate what DFA is, how it is different from NFA, and why regular expressions are not always the best choice.
Then you will follow on grammars. Context free grammars, left recursion elimination and so on.
After that you will be presented with tools that will make your life easier. Yacc, Bison, monadic parsers.
This usually happens 200-300 pages into the book. And while this is very important part of the story, I would like to argue this can be postponed to the point where you actually know what you are doing.
Therefore approach in this book will take us as fast as possible to the actual interpretation, skipping all unnecessary steps if possible.
To begin with we will start with arithmetic expressions.
** The simplest expressions you can think of
Implementing anything on JVM starts with interfaces.
let's us to the same and implement your first Expression
#+begin_src kotlin
interface Expression
#+end_src

It's not much, but we will improve it really fast. Just stay tuned.
*** Integer values
It is hard to do any computations when you don't have numbers.
#+begin_src kotlin
data class EInt(val v:Int):Expression
#+end_src
For now integers are more than enough for us to have. Adding boolean and float values will follow.
*** Addition
Adding additional addition to the mix would not be a problem
#+begin_src kotlin
data class EAdd(val a:EInt, val b:EInt): Expression

#+end_src
*** Multiplication
The same goes for the multiplication
#+begin_src kotlin
data class EMul(val a:EInt, val b:EInt): Expression
#+end_src
** What else can we add to the expressions
** Representing expressions in a code
Now we have all the required components to actually start calulating.
How would expression
#+begin_src kotlin
2+2
#+end_src
would look in our data class representation?
#+begin_src kotlin
EAdd(2,2)
#+end_src
Multiplication would not be that different
#+begin_src kotlin
5*5
#+end_src
#+begin_src kotlin
EMul(5, 5)
#+end_src
And if we want to express something more complex, we will just nest them
#+begin_src kotlin
(2+2)*5*5
#+end_src
#+begin_src kotlin
EMul(5, EMul(5, EAdd(2 , 2)))
#+end_src

* Evaluating expressions for fun and profit
** Evaluating integers. As simple as it gets
Having expresisons is nice, but why do we need them if we can't calculate them on the fly?
as TDD teaches us, you whould start from the test first.
So be it.
You never can be too slow when doing unit tests. Good coverage for the basics will let you know details of your code workings. As well will save you hours of debugging later on.

#+begin_src kotlin
    @Test
    fun testSimpleInteger(){
        assertEquals(EInt(5), eval(EInt(5)))
        assertEquals(EInt(-5), eval(EInt(-5)))
        assertEquals(EInt(0), eval(EInt(0)))
    }
#+end_src

What would be the easiest implementation of *eval* to make it run?
I came up with this one.
#+begin_src kotlin

fun eval( e:Expression): Expression{
    return e;
}
#+end_src
Probably would not require a lot of effort to understand what is happening here.
and it also makes our tests green.


** Evaluating addition
Now we are facing our first real challenge.
How can we evaluate addition?

As usual, let us start with the unit tests, so we don't have a suprises later on.
#+begin_src kotlin
 @Test
    fun testSimpleAddition(){
        assertEquals(EInt(5), eval(EAdd(EInt(5), EInt(0))))
        assertEquals(EInt(5), eval(EAdd(EInt(0), EInt(5))))
        assertEquals(EInt(10), eval(EAdd(EInt(7), EInt(3))))
        assertEquals(EInt(7), eval(EAdd(EInt(-3), EInt(10))))
        assertEquals(EInt(6), eval(EAdd(EInt(10), EInt(-4))))
    }
#+end_src

obviously if we try to run them now, we would have an error

#+begin_src kotlin
Expected :EInt(v=5)
Actual   :EAdd(a=EInt(v=5), b=EInt(v=0))
#+end_src
By the way - this is one of the reasons Kotlin is a nice language for these kind of exercises.
You don't need to write a lot of boilerplates for the *data class*, string representation looks reasonalbe, and saves some mental space for more important things.

We have a red test. What is the simplest way to make it green?
#+begin_src kotlin

fun eval( e:Expression): Expression{
    if(e is EAdd){
        return EInt( e.a.v + e.b.v)
    }
    return e
}
#+end_src

would this be enough?

Oh wow, tests are green now. But i am not big fan of 'e.a.v' looks very obscure
Green test allows us to do refactoring bit.

#+begin_src kotlin
data class EInt(val value:Int):Expression

fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        return EInt(expression.a.value + expression.b.value)
    }
    return expression
}
#+end_src

Are we done with the addition?

What about more complex example?
#+begin_src kotlin
1 + 2 + 3 => 6
assertEquals(EInt(6), eval( EAdd(EInt(1), EAdd( EInt(2),EInt(3)) )))
#+end_src

And our compiler complains.
#+begin_src
Type mismatch: inferred type is EAdd but EInt was expected
#+end_src

Why is that? Oh yes. in our definition we are expecitng that *EAdd* expects integers as a parameters.
#+begin_src kotlin
data class EAdd(val a:EInt, val b:EInt): Expression
#+end_src
But now we are trying to pass *EAdd* as second paramter. Of course we should have an error here.

As usual with TDD approach we fixe it with the simplest way possible
#+begin_src kotlin
data class EAdd(val a:Expression, val b:Expression): Expression
#+end_src

Hopefully it will solve our issue.

But apparently it would not.

We get yet another nasty error in our *eval* function

#+begin_src kotlin
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        return EInt(expression.a.value + expression.b.value)
        //                         ^
        //                         |
        // unresolved reference: value
    }
    return expression
}
#+end_src

Any ideas?
Sure. *value* is a field of and integer, and now EAdd works with generic expressions, which might not have a value.
So we need to come up with a way of converting addition result to values.

#+begin_src kotlin
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    return expression
}
#+end_src
This expression is worth to take a closer look.
To execute and addition, we need to be sure that both our parameters are integers.
At the same time when we call *eval* we would get the *Expression* as a result.
Therefore we need to convert it to the class we want. In our case that would be *EInt*.

Of course this little piece of code might rise some questions.
What happens if during *eval* will return something different from *EInt* would not that break everything?
What will happen if during *eval* some error will be raised?
These are very good questions. and we will get to them later. For now let us keep our focus on general picture.

** Evaluating multiplication
After spending so much time on evaluating addition, expanding our expressions to support multiplication is straighforward.
But first - tests.
#+begin_src kotlin
    @Test
    fun testSimpleMultiplication()
    {
        assertEquals(EInt(0), eval(EMul(EInt(0), EInt(42))))
        assertEquals(EInt(0), eval(EMul(EInt(42), EInt(0))))
        assertEquals(EInt(42), eval(EMul(EInt(1), EInt(42))))
        assertEquals(EInt(42), eval(EMul(EInt(42), EInt(1))))
        assertEquals(EInt(4), eval(EMul(EInt(2), EInt(2))))
    }
#+end_src

and implementation
#+begin_src kotlin
fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    if(expression is EMul){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value * right.value)
    }
    return expression
}
#+end_src

As you can see, the implementation is almost identical. The only difference we have Ñ–s the actual operation.

Let's add few more tests to make sure it works if we mix addition and multiplication
#+begin_src kotlin
    @Test
    fun testComplicatedMultiplication() {
        assertEquals(EInt(10), eval(EMul(EMul(EInt(1), EInt(5)), EInt(2))))
        assertEquals(EInt(12), eval(EMul(EAdd(EInt(1), EInt(5)), EInt(2))))
    }

#+end_src
All the tests are green. Nice.
In less than 20 lines of code we have working caclulator that can add and multiply arbitrary numbers.
#+begin_src kotlin
interface Expression
data class EInt(val value:Int):Expression
data class EMul(val a:Expression, val b:Expression): Expression
data class EAdd(val a:Expression, val b:Expression): Expression

fun eval( expression:Expression): Expression{
    if(expression is EAdd){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value + right.value)
    }
    if(expression is EMul){
        val left: EInt = eval(expression.a) as EInt
        val right: EInt  = eval(expression.b) as EInt
        return EInt(left.value * right.value)
    }
    return expression
}

#+end_src


** Sidenotes
*** Moving evaluation into each expression
At this point all our evaluation is sitting within one *eval* function.
If we gonna add more expressions to the interpreter, amount of *if* statements will grow.
This can be avoided by extracting specific parts of the code, and moving them to expressions.
The result would look like this:
#+begin_src kotlin
interface Expression{
    fun eval():Expression
}
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }
}

data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value + right.value)

    }
}
#+end_src

It would require to change the test implementation as well.

#+begin_src kotlin
 assertEquals(EInt(12), (EMul(EAdd(EInt(1), EInt(5)), EInt(2))).eval())

#+end_src
*** Simple optimisations
You might agree that multiplying anything by zero would not help a lot.
We can include it in our evaluation of *EMul*
#+begin_src kotlin
data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return EInt(0)
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}
#+end_src

And if you agree that integers are immutable values, we can avoid creating new copy of the EInt every time during the evaluation

#+begin_src kotlin
val zeroInt = EInt(0)

data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return zeroInt
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }
}
#+end_src
* The simplest parser you can think of
To make the whole parsing easy, let us reiterate what problem are we trying to solve.
We need to take a string, and convert it to the expression.
It can be expressed in a test.
#+begin_src kotlin
    @Test()
    fun testSimpleInt(){
        assertEquals(EInt(42), parse("42"))
    }
#+end_src

As you might remember - we are lazy. So we will do something that would allow us to simplify things.
To use a library and a format a lot of people using now.
The most popular programming language of the century.
YAML.

** Parsing integers with yaml
To make it work we would need to add dependency to the great *snakeyaml* library
#+begin_src kotlin
dependencies {
    // https://mvnrepository.com/artifact/org.yaml/snakeyaml
    implementation("org.yaml:snakeyaml:1.32")

    testImplementation(kotlin("test"))
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.0")
}
#+end_src

having such a useful tool makes our lives easy.

#+begin_src kotlin
import org.yaml.snakeyaml.Yaml

fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return EInt(script as Int)
}
#+end_src

We cannot parse anything but integers now, but at least our tests are green. Isn't that great?
** Expanding yaml expressions to support addition
If you remember, our goal is to convert from strings to expressions as easy as possible.
To make it happen, the language we would use should be very similar to the expressions we have.

#+begin_src kotlin
EAdd(EInt(3), EInt(5))
#+end_src

might be represented in yaml as
#+begin_src yaml
add
  - 3
  - 5
#+end_src

And more complex expresison
#+begin_src kotlin
EMul(EInt(10), EAdd(EInt(1), EInt(2)))
#+end_src
Will have a form
#+begin_src yaml
mul
  - 10
  - add
    - 1
    - 2
#+end_src

Obviously this is good enough if we want to use it as part of yaml files.
But when you adding such an expression to the unit test, you would suffer.
Suffering should be optional, and to removing it we will utilise little known feature of Yaml, called https://yaml.org/spec/1.2.2/#chapter-7-flow-style-productions

#+begin_src kotlin
EAdd(EInt(3), EInt(5))
#+end_src
becomes
#+begin_src yaml
[add, 3, 5]
#+end_src

and
#+begin_src kotlin
EMul(EInt(10), EAdd(EInt(1), EInt(2)))
#+end_src
is represented as

#+begin_src yaml
[mul, 10, [add, 1, 2]]
#+end_src
I kinda like it. It is shorter, and represents our internal structure pretty much
** parsing yaml with predefined expressions
Test goes first
#+begin_src kotlin
   @Test()
    fun testSimpleAdd(){
        assertEquals(EAdd(EInt(3), EInt(5)), parse("[add, 3, 5]"))
    }
#+end_src

When *snakeyaml* parses flow-style expressions, it returns ArrayList.
So all we need to do is convert ArrayList to expression we want

#+begin_src kotlin
fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):Expression{
   if(obj is Int){// if yaml loaded an integer -convert it to EInt
       return EInt(obj)
   }
    if(obj is ArrayList<*>){ // if we have arrayList
        val operation= obj[0] // we assume initial element is the name of operation
        if(operation == "add"){
            val left = convert(obj[1]) // converting first parameter of the operation
            val right = convert(obj[2]) // converting second parameter of the operation
            return EAdd(left, right)
        }
    }
    return EInt(-42) // since we don't have errors now, return something strange
}
#+end_src

Essentially what we are doing here is very similar to the eval fucntion we defined previously.
Eval takes Expression as input and returns Integer values.
parse takes a string as an input and returns Expression.
Even conversion of addition look very similar. Pay attention to the recursive call in convert.

Of course if our source code would not have the structure we want, we will get very nasty errors.
But as was said previousy - let us focus on successful flow first, taking care of corner cases later.

Surprisingly enough, this implementation makes our test green.
Let's see if we try to parse more complicated expression.
#+begin_src kotlin
    @Test
    fun testComplicatedAdd(){
        assertEquals(
            EAdd(EAdd(EInt(3), EInt(5)), EInt(42)),
            parse("[add, [add, 3,5], 42]"))
    }

#+end_src

Green as well. Nice work!
** Adding multiplication to the mix
Now we know what to expect, so we will add both tests from the beginning
#+begin_src kotlin
    @Test
    fun testSimpleMultiplication(){
        assertEquals(EMul(EInt(11), EInt(33)), parse("[mul, 11, 33]"))
    }
    @Test
    fun testComplicatedMultiplication(){
        assertEquals(
            EMul(EMul(EInt(3), EInt(5)), EInt(42)),
            parse("[mul, [mul, 3,5], 42]"))
    }
#+end_src

Implementation of parser is really simple. Nothing new under the sun.
#+begin_src kotlin
fun convert(obj:Any):Expression{
    ...
    if(obj is ArrayList<*>){
        ...
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EMul(left, right)
        }
#+end_src

We have a parser for addition, and we have a parser for multiplication.
Let's see how well they are working together.
#+begin_src kotlin
    @Test
    fun testMulAndAdd(){
         assertEquals(
            EMul(EAdd(EInt(22), EInt(11)), EInt(44)),
            parse("[mul, [add, 22, 11], 44]"))
    }
#+end_src

Tests are green. Feels great, isn't it?

** Evaluating parsed expressions
Now we have both parth of the story. We can take a string and convert it to an expression.
We can take an expression and evaluate it.
Let us add some more tests would confirm this fact.
#+begin_src kotlin
    @Test
    fun testComplicatedExpressionWithParsing() {
        assertEquals(EInt(10), (EMul(EMul(EInt(1), EInt(5)), EInt(2))).eval())
        assertEquals(EInt(10), parse("[mul, [mul, 1, 5], 2]").eval())
        assertEquals(EInt(12), (EMul(EAdd(EInt(1), EInt(5)), EInt(2))).eval())
        assertEquals(EInt(12), parse("[mul, [add, 1, 5], 2]").eval())
    }
#+end_src

I specifically put original version here, so it is easy to compare complexity of expressions and amount of brackets.

** One more touch
If you look closely on the previous test, you might wondered, why did we use *EInt(10)* instead of just *10*? How hard would that be to make it happen?

Well, let's add one more operation, and call it *unparse*. It will take an expression and convert it to our yaml format. in such a way we will have the whole circle of life

Let us extend our expression interface with *unparse* method
#+begin_src kotlin
interface Expression{
    fun eval():Expression
    fun unparse():String
}
#+end_src

And expand our test cases for the parsing.
Make sure that unparsing parsed expression should give the same result
#+begin_src kotlin

  @Test
    fun testSimpleIntUnparse(){
        assertEquals("42",EInt(42).unparse())
        assertEquals("42", parse("42").unparse())
    }

    @Test
    fun testSimpleAddUnparse(){
        val yaml = "[add, 3, 5]"
        assertEquals(yaml, EAdd(EInt(3), EInt(5)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testComplicatedAddUnparse(){
        val yaml = "[add, [add, 3, 5], 42]"
        assertEquals(
            yaml,
            EAdd(EAdd(EInt(3), EInt(5)), EInt(42)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testSimpleMultiplicationUnparse(){
        val yaml = "[mul, 11, 33]"

        assertEquals(yaml, EMul(EInt(11), EInt(33)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testComplicatedMultiplicationUnparse(){
        val yaml = "[mul, [mul, 3, 5], 42]"
        assertEquals(
            yaml,
            EMul(EMul(EInt(3), EInt(5)), EInt(42)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }
    @Test
    fun testMulAndAddUnparse(){
        val yaml = "[mul, [add, 22, 11], 44]"
        assertEquals(
            yaml,
            EMul(EAdd(EInt(22), EInt(11)), EInt(44)).unparse())
        assertEquals(yaml, parse(yaml).unparse())
    }

#+end_src

Remember, the more tests you have, the less corner cases you should worry about.

implementation is straightforward.

#+begin_src kotlin
data class EInt(val value:Int):Expression {
    ...
    override fun unparse(): String {
        return value.toString()
    }
}

data class EMul(val a:Expression, val b:Expression): Expression {
    ...
    override fun unparse(): String {
        return "[mul, ${a.unparse()}, ${b.unparse()}]".format()
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    ...
    override fun unparse(): String {
        return "[add, ${a.unparse()}, ${b.unparse()}]"
    }
}
#+end_src
As expected, tests are passing.
** Evaluating parsed expressions
We took some detour to make the basics work. Now we know how to read yaml, interpret the contents of the yaml using intermediate representation, and save results back to the yaml. Which in turn can be read, interpreted and saved to yaml.

But what is missing is some tests that confirm that our assumptions are correct.
#+begin_src kotlin
 @Test
    fun testSimpleIntegerWithParsing() {
        assertEquals(EInt(5), parse("5").eval())
        assertEquals(EInt(-5),parse("-5").eval())
        assertEquals(EInt(0), parse("0").eval())
    }

    @Test
    fun testSimpleAdditionWithParsing() {
        assertEquals(EInt(5), parse("[add, 5, 0]").eval())
        assertEquals(EInt(5), parse("[add, 0, 5]").eval())
        assertEquals(EInt(10),parse("[add, 7, 3]").eval())
        assertEquals(EInt(7), parse("[add, -3, 10]").eval())
        assertEquals(EInt(6), parse("[add, 10, -4]").eval())
    }

    @Test
    fun testComplexAdditionWithParsing() {
        assertEquals(EInt(6),  parse("[add, 1, [add, 2,3]]").eval())
    }

    @Test
    fun testSimpleMultiplicationWithParsing() {
        assertEquals(EInt(0), parse("[mul, 0, 42]").eval())
        assertEquals(EInt(0), parse("[mul, 42, 0]").eval())
        assertEquals(EInt(42),parse("[mul, 1, 42]").eval())
        assertEquals(EInt(42), parse("[mul, 42, 1]").eval())
        assertEquals(EInt(4), parse("[mul, 2, 2]").eval())
    }

    @Test
    fun testComplicatedMultiplicationWithParsing() {
        assertEquals(EInt(10), parse("[mul, 1, [mul, 5, 2]]").eval())
        assertEquals(EInt(12), parse("[mul, 2, [add, 5, 1]]").eval())

        assertEquals("10", parse("[mul, 1, [mul, 5, 2]]").eval().unparse())
        assertEquals("12", parse("[mul, 2, [add, 5, 1]]").eval().unparse())
    }
#+end_src

In the last test you can see all the parts working together.
And as you might have guessed, our tests are passing.
** Food for thought
Parsing plays important role in the whole evaluation process. While we simplified it to the minimum, we still can improve it.

For example - we have duplication while parsing addition and multiplication operations.
One way to make it better would be to add support to binary arithmetical operations.
But that would come at the cost of complicating our abstract syntax tree. As usual in the computer science - you cannot remove the complexity. You can just move it in some other place.

Here's another puzzle for you. What should this expression be parsed into?
#+begin_src kotlin
[mul, 0, [add, 11, 42]]
#+end_src

One might argue it is obvious - result is
#+begin_src kotlin
EMul(EInt(0), EAdd(EInt(11), EInt(42)))
#+end_src

But equally good option is
#+begin_src kotlin
EInt(0)
#+end_src

Since we know that multiplication by zero would give us zero in the end, why bother creating complex expression?
And as in previous example - we are simplifiying evaluation by complicating parsing.
You cannot remove the complexity. You can just push it somewhere else.
** Reflecting and Wrapping up
It took some time and turns to get to this point.
A lot of text, and a lot of explanations. But try to look at it from the different perspective.
our parser is 26 lines long, and our interpreter is just 42 lines long.
In less than 100 lines we have fully functional interpreter, that can deal with complex math expressions.
And load and save expressions to yaml.

Let's look at our code in its full glory.
#+begin_src kotlin
// Domain.kt
interface Expression{
    fun eval():Expression
    fun unparse():String
}
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}

val zeroInt = EInt(0)
data class EMul(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        if (left.value == 0){
            return zeroInt
        }
        val right = b.eval() as EInt
        return EInt(left.value * right.value)
    }

    override fun unparse(): String {
        return "[mul, ${a.unparse()}, ${b.unparse()}]".format()
    }
}

data class EAdd(val a:Expression, val b:Expression): Expression {
    override fun eval(): Expression {
        val left = a.eval() as EInt
        val right = b.eval() as EInt
        return EInt(left.value + right.value)

    }

    override fun unparse(): String {
        return "[add, ${a.unparse()}, ${b.unparse()}]"
    }
}
// Parser.kt
import org.yaml.snakeyaml.Yaml

fun parse(input:String):Expression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):Expression{
   if(obj is Int){
       return EInt(obj)
   }
    if(obj is ArrayList<*>){
        val operation= obj[0]
        if(operation == "add"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EAdd(left, right)
        }
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return EMul(left, right)
        }
    }
    return EInt(-42)
}
#+end_src
* Core language, host language and a lot of sugar
When implementing and interpreter you want to have ability to define new type of capabilites.
At the same time you don't want to spend too much time refactoring base implementation.
Changing Ast and tests for it, implementations, is very time consuming process.
** core, host, sugared
This can be avoided by introducing new level of abstration. As you know, you can solve every problem in IT by adding an additional level of abstraction.
Let's call our arimetic language we have the core language. It is core of our interpreter, and we don't want to expose its internal for the customers.
We would like to keep it as small as possible, so all refatoring and optimisations would have smaller blast radius.
As for ease of use we can create new expressions, which we would call sugared expressions.
They will be used as our interface, and should be converted to the core language to be interpreted
** Adding sugar
Let's say we want to add new operation to the mix *sub*, which stands for the substraction.
how would it fit to our idea of sugared language?
#+begin_src kotlin
interface SugarExpression{
    fun desugar():Expression
}

data class SugarInt(val v:Int):SugarExpression{
    override fun desugar(): Expression {
        return EInt(v)
    }
}

data class SugarAdd(val left:SugarExpression, val right:SugarExpression) : SugarExpression{
    override fun desugar(): Expression {
       return EAdd(left.desugar(), right.desugar())
    }

}

data class SugarMul(val left:SugarExpression, val right:SugarExpression): SugarExpression{
    override fun desugar(): Expression {
       return EMul(left.desugar(), right.desugar())
    }
}
#+end_src
Now it is pretty much replicating what with had with the usual expression.
Main difference might be that we don't evaluate anything here. We're just converting Sugared expression to our core expressions.

*** Defining substraction
Now we can extend our sugared languge with substraction function.
#+begin_src kotlin

// Take a closer look at this method
data class SugarSub(val left:SugarExpression, val right: SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EAdd(left.desugar(),  EMul(EInt(-1), right.desugar() ))
    }
}
#+end_src

Just have a look.
We don't have substraction at our core language. But our customers might never know about it.
For what they care, they can call *sub* function, and it would return the expected result to them.
Isnt' that nice?

But sharp-eyed reader might notice, that this implemantation would not work.
Our parser returns Expressions, not SugarExpressions. We need to change that.
And add few more unit tests to the mix.

our parser looks like this now
#+begin_src kotlin
import org.yaml.snakeyaml.Yaml

fun parse(input:String):SugarExpression{
    val yaml = Yaml()
    val script = yaml.load<Any>(input)
    return convert(script)
}
fun convert(obj:Any):SugarExpression{
   if(obj is Int){
       return SugarInt(obj)
   }
    if(obj is ArrayList<*>){
        val operation= obj[0]
        if(operation == "add"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarAdd(left, right)
        }
        if(operation =="mul"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarMul(left, right)
        }
        if(operation =="sub"){
            val left = convert(obj[1])
            val right = convert(obj[2])
            return SugarSub(left, right)
        }
    }
    return SugarInt(-42)
}
#+end_src

our tests should be changed in quite a few places. For example, parsing should be updated
#+begin_src kotlin
 @Test
    fun testComplicatedMultiplicationUnparse(){
        val yaml = "[mul, [mul, 3, 5], 42]"
        assertEquals(
            yaml,
            SugarMul(SugarMul(SugarInt(3), SugarInt(5)), SugarInt(42)).desugar().unparse())
        assertEquals(yaml, parse(yaml).desugar().unparse())
    }
    @Test
    fun testMulAndAddUnparse(){
        val yaml = "[mul, [add, 22, 11], 44]"
        assertEquals(
            yaml,
            SugarMul(SugarAdd(SugarInt(22), SugarInt(11)), SugarInt(44)).desugar().unparse())
        assertEquals(yaml, parse(yaml).desugar().unparse())
    }
#+end_src
Do you see this beatuful pattern of parse -> desugar -> unparse

Of course, evaluation tests should be changed as well
#+begin_src kotlin
 @Test
    fun testComplicatedMultiplicationWithParsing() {
        assertEquals(EInt(10), parse("[mul, 1, [mul, 5, 2]]").desugar().eval())
        assertEquals(EInt(12), parse("[mul, 2, [add, 5, 1]]").desugar().eval())

        assertEquals("10", parse("[mul, 1, [mul, 5, 2]]").desugar().eval().unparse())
        assertEquals("12", parse("[mul, 2, [add, 5, 1]]").desugar().eval().unparse())
    }
#+end_src

they follow the same pattern more or less. parse -> desugar -> eval -> unparse

Now that our little refactoring is done, we are in a good shape to add test for our substraction.

#+begin_src kotlin
    @Test
    fun testMulAndSubUnparse(){

        val yaml = "[mul, [sub, 22, 11], 44]"
        val desugared = "[mul, [add, [mul, -1, 22], 11], 44]"
        assertEquals(
            desugared,
            SugarMul(SugarSub(SugarInt(22), SugarInt(11)), SugarInt(44)).desugar().unparse())
        assertEquals(desugared, parse(yaml).desugar().unparse())
    }
#+end_src

It is a good idea to test that evaluation of substraciton works as well.

#+begin_src kotlin
    @Test
    fun testMulAndSubEvaluationWithParsing(){
        val yaml = "[mul, [sub, 22, 11], 44]"
        assertEquals("484", parse(yaml).desugar().eval().unparse())
    }
#+end_src

We've just expanded our language with one more built-in function, wihout touching the core interpretation logic. And whast is even more interesting - the result of evaluation is correct.
** Adding negation operation
Now we can expand our primitive list by adding operation *neg* which should change the sight of the operation.

Since we're working with the sugared operations, we can approach to this having this definition
#+begin_src kotlin
data class SugarNeg(val value:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EMul(EInt(-1), value.desugar())
    }

}
#+end_src

Or we might go other way around.

#+begin_src kotlin
data class SugarNeg2(val value:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return SugarSub(SugarSub(value, value), value).desugar()
    }

}
#+end_src

Second one would not be the most efficient implementation, but would reduce our dependency on the core language. As you might see there's no core language structures besides *Expression* as return value.

This is a great example of flexibility sugaring and desugaring brings to the table.

If we implemented negation first, we might change our implementation of *sub* as well.
#+begin_src kotlin
data class SugarSub2(val left:SugarExpression, val right:SugarExpression):SugarExpression{
    override fun desugar(): Expression {
       return EAdd(SugarNeg(left).desugar(), right.desugar())
    }
}
#+end_src

As you can see, sugaring gives a lot of flexibility towards how our functions are implemented.

Let's finish our negation by adding some tests and parsing bits.
#+begin_src kotlin
        if(operation =="neg"){
            val value = convert(obj[1])
            return SugarNeg(value)
        }
#+end_src

and test cases for the parsing
#+begin_src kotlin
    @Test
    fun testNegUnparse()
    {
        val yaml = "[neg, [mul, 2, 10]]"
        val desugared = "[mul, -1, [mul, 2, 10]]"
        assertEquals(desugared, SugarNeg(SugarMul(SugarInt(2), SugarInt(10))).desugar().unparse())
        assertEquals(desugared, parse(yaml).desugar().unparse())
    }
#+end_src

and for the evaluation as well
#+begin_src kotlin
    @Test
    fun testNegationEvaluation(){
        val yaml = "[neg, [mul, [sub, 22, 11], 44]]"
        assertEquals("-484", parse(yaml).desugar().eval().unparse())
    }
#+end_src

Remember, there's no such thing as too many tests, if they all make sense.


We will get back to the sugaring concept later. It is very powerful idea worth revisiting.

** Food for thought
- You want to add *uminus* operation, which is operates exactly like negation, but has different representation in yaml syntax.
  #+begin_src yaml
[uminus, [mul, [sub, 22, 11]], 44]
  #+end_src
  Can you think of a way to make this evaluation possible touching only parsing?

* Adding primitive functions to the language
Now that we know how to add new functions as part of our sugaring process, we might ask ourselves :
"Is it possible to define new functions without touching the host language"?
Now every new defined function should have some correspondence in Kotlin.
It would be nice to make it happen in yaml directly.

Let's come up with the syntax for the function definition.
It might have a lot of different flavors, but all of them should take care of few elements
0. keyword for function definition
1. function name
2. function arguments
3. body of the function

We can start with the double function
#+begin_src yaml
fun   # keyword for the function definition
 - [double, x]  # function name and arguments
 - [add, x, x]  # body of the function
#+end_src

Of course short version would be preferrable for unit tests.
#+begin_src yaml
[fun, [double, x], [add, x, x]]
#+end_src

After defining *double* function, it is really tempting to introduce *quad* function

#+begin_src yaml
[fun, [quad, x], [double, [double, x]]]
#+end_src
functions should be able to call one another, otherwise what is the point in defining them?


Functions without parameters should also be possible.

#+begin_src yaml
[fun, [const42], 42]
#+end_src

We will work with functions having single argument for now, and will deal with multiple arguments representation little bit later.

** Dealing with function and argument names
Now we have a good understanding how our function definitions would look like in yaml, let's think about how we gonna represent them in Kotlin.

Before we start implementing anyting, we need to decide, how we can represent function and variables names.

#+begin_src yaml
[fun, [double, x], [add, x, x]]
#+end_src

When looking into this expression from yaml perspective `x` and `double` will be represented as strings.
But semantically they should be different. They should represent some identifier, or a symbol if you wish.

Therefore we need to expand our parser to support symbols.

#+begin_src kotlin
data class ESymbol(val value:String):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value
    }
}

#+end_src

Here how our representation would look like
#+begin_src kotlin
data class EFunDef(val name:ESymbol, val argument:ESymbol, val body:Expression):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return "[fun, [${name.unparse()}, ${argument.unparse()}], ${body.unparse()}]"
    }
}

#+end_src

Function definition is evaluated to itself. It is just a delcaration of the function, it doesn't do anything at all.

To make a function call, we need to have different structure. In some places it is called *function application*, i would use *function call*, since it is less academic and more commonly used
#+begin_src kotlin
data class EFunCall(val name:ESymbol, val argument:Expression):Expression{
    override fun eval(): Expression {
        TODO("Not yet implemented")
    }

    override fun unparse(): String {
        return "[${name.unparse()}, ${argument.unparse()}]"
    }

}
#+end_src

We dont' know exactly how evaluation will work, but we can alreade expand our parser to support both function definitions and function calls.
** Expanding parser for function definitions and calls
When we are starting new implementation, and not totally sure what expected result is, we write tests.
Parsing function definition looks like a good point.


* Pros and cons of sugaring
** performance hit
** simplified runtime
** Haskell core language
** targeting degugaring
** WebAssembly desugar
** python desugar

* Errors and strange things
** adding division
** what should happen if we divide by zero?
** It's all about environment
* Defining variables for fun and profit
While working with the expressions, it might be useful to have some variables.
for example, ability to compute something like this:
#+begin_src yaml
[mul, x, 3]
#+end_src
To make it happen, we need to do some preparations.
First of all, we need to understand what `x` means during parsing.
Secondly, we should take the value attached to `x` from somewhere.

If we try to use default yaml parser, it will say that `x` is represented as a string.
And while we are not working with strings in our language at the moment, we definitely will be in the future.
So during parsing we shall convert this string to some new type of the data.
Something that can be treated as identifier or variable name. Let's call it a symbol

#+begin_src kotlin
data class ESymbol(val value:String):Expression{
    override fun eval(): Expression {
        return this
    }

    override fun unparse(): String {
        return value
    }
}

data class SugarSymbol(val name:String):SugarExpression{
    override fun desugar(): Expression {
       return ESymbol(name)
    }

}
#+end_src
Here's an example how it should work
#+begin_src kotlin
    @Test
    fun testOperationWithSymbol(){
        assertEquals(SugarAdd(SugarSymbol("x"), SugarInt(5)),
                     parse("[add, x, 5]"))

        assertEquals(SugarAdd(SugarSymbol("x"), SugarSymbol("y")),
                     parse("[add, x, y]"))

        assertEquals(SugarAdd(
                         SugarAdd(SugarSymbol("x"), SugarSymbol("y")),
                        SugarSymbol("z")),
            parse("[add, [add, x, y], z]"))

    }
#+end_src
Now we have a way to introduce variables to the expressions, but how are we planning to evaluate them?
Which brings us to the next question
** Where do our variables live?
Variables should be defined somewhere. There should be a binding between symbol, and the value that symbol represents.

The easiest way to make this mapping would be a dictionary. Or a hashmap if you like.

#+begin_src kotlin
data class Environment(val bindings:HashMap<ESymbol, Expression>){
    fun addBinding( name:ESymbol,  value:Expression){
        bindings[name] = value
    }
    fun isDefined(name:ESymbol): Boolean{
        return bindings.containsKey(name)
    }
    fun get(name:ESymbol):Expression{
        return bindings[name]!!
    }
}
#+end_src
As you can see we are assuming that we use core language as part of bindings.
Since our evaluation process works on the core language, not the sugared one, this is very logical thing to do.

Test cases are following:

#+begin_src kotlin

    @Test
    fun isDefined() {
        val env = Environment(hashMapOf())
        assertFalse(env.isDefined(ESymbol("x")))
        val env2 = Environment(hashMapOf( Pair(ESymbol("x"), EInt(5))))
        assertTrue(env2.isDefined(ESymbol("x")))
    }
    @Test
    fun addBinding() {
        val env = Environment(hashMapOf())
        env.addBinding(ESymbol("x"), EInt(5))
        assertTrue(env.isDefined(ESymbol("x")))
        assertEquals(EInt(5), env.bindings[ESymbol("x")])
        assertEquals(EInt(5), env.get(ESymbol("x")))

    }
#+end_src

What would happen if you try to get the variable that is not defined in the environment?
You will get a runtime error of course. Error handling will be taken care of later. I promise :)
Let us focus on well-behaving programs, where nothing strange happens.

** Using environment in the evaluation
We know how to define variable, and bind values to them.
But it wont' be useful until we can attach this environment to our evaluation.
#+begin_src yaml
## somewhere out here we should have an environmet with defined 'x'
[add, x, 5]
#+end_src

The only place where we can plug it in is our *eval* function.
Time for the improvement

Remeber our *Expression* interface from very long time ago?
#+begin_src kotlin
interface Expression{
    fun eval():Expression
    fun unparse():String
}
#+end_src

We will tweak it a little bit

#+begin_src kotlin
interface Expression{
    fun eval(env:Environment):Expression
    fun unparse():String
}
#+end_src

We're claiming here that evaluation cannot happen in vacuum. We need to take into account an environment we're in.
Sometimes it might be an empty environment, somethimes it might be full of variable definitions.

This is a small step for our interface, but a huge impact for our interpreter.
It breaks all our evaluation implementations.
It breaks all our evaluation tests.
Good news is that we have tests, so we know what is broken.
What else can be done rather than fixing it?

** Fixing evaluation with environment
Our first case is really simple one.
#+begin_src kotlin
data class EInt(val value:Int):Expression {
    override fun eval(): Expression {
        return this
    }
   ...
}
#+end_src

How shall we interpret integer values if they live in some environment?
Easy. Integers are always integers, so we can simply ignore the environment.

#+begin_src kotlin
data class EInt(val value:Int):Expression {
    override fun eval(env:Environment): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}
#+end_src

Done.

With addition and multiplication it would be not as straighforward.

Let's stop and think for a moment.
What we would like to happen when we have an expression defined within environment?
#+begin_src yaml
## env: {x = 5}
[add, x, 10]
#+end_src

I would say it should be converted to
#+begin_src yaml
[add, 5, 10]
#+end_src
We don't care about the variable name. We care only about value attached to it. Its binding.

Having variable name, variable definition and expression where this variable exists, we want to substitute variable with its value.

#+begin_src kotlin
fun substitute(variableName:ESymbol), env:Environment, expession:Expression): Expression
#+end_src

If you're thinking this function should be part of the *Expression* interface, in tend to agree with you.

Our poor *Expression* is getting bigger and bigger, but it is a good things.

#+begin_src kotlin
interface Expression{
    fun eval(env:Environment):Expression
    fun substitute(symbol:ESymbol, env:Environment):Environment
    fun unparse():String
}
#+end_src

Now it breaks even more things in our code. But this is the price we need to pay.

#+begin_src kotlin
data class EInt(val value:Int):Expression {
    override fun eval(env:Environment): Expression {
        return this
    }

    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return this
    }

    override fun unparse(): String {
        return value.toString()
    }
}
#+end_src

for integers substituion is as easy as it gets.
We are just ignoring all the symbols and environment.

Let's see what we can do with *ESymbol*.
#+begin_src kotlin
data class ESymbol(val name:String):Expression{
    ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){
            return env.get(symbol)
        }
        return this
    }
   ...
}
#+end_src

if we are trying to substitue symbol, and it is definted in the environment, we will return record from the variable.

It might sound little bit confusing so here are few examples.

#+begin_src yaml
# env: {x = 5}
x
#+end_src

should be transformed to

#+begin_src yaml
5
#+end_src

And if variable is not bound in the environment
#+begin_src yaml
# env: {x = 5}
y
#+end_src

should remain untouched
#+begin_src yaml
y
#+end_src


Now that we've done with substitution for the symbols, addition and multiplication should be simple enough.

#+begin_src kotlin
data class EAdd(val a:Expression, val b:Expression): Expression {
   ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return EAdd(a.substitute(symbol, env), b.substitute(symbol,env))
    }
   ...
}

data class EMul(val a:Expression, val b:Expression): Expression {
    ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        return EMul(a.substitute(symbol, env), b.substitute(symbol, env))
    }
   ...
}

#+end_src

As usual, our tests would show us an example what we expect to happen, and how the variable substitution should look like.

#+begin_src kotlin
 @Test
    fun testSubstitution(){
        val env1 = Environment(hashMapOf(Pair(ESymbol("x"), EInt(5))))
        assertEquals(EInt(5), ESymbol("x").substitute(ESymbol("x"), env1))
        assertEquals(ESymbol("y"), ESymbol("y").substitute(ESymbol("x"), env1))

        assertEquals("[add, 5, 5]",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())

        assertEquals("[mul, 5, 5]",
            parse("[mul, x, x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())

        assertEquals("[add, [mul, 5, 5], 5]",
            parse("[add, [mul, x, x], x]").desugar()
                .substitute(ESymbol("x"), env1).unparse())


        val env2 = Environment(hashMapOf(Pair(ESymbol("x"), EInt(5)),
            Pair(ESymbol("y"), EInt(7))))
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2).unparse())


        assertEquals("[add, [mul, 5, 7], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .substitute(ESymbol("y"), env2)
                .unparse())

        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[mul, 11, [add, [add, 3, 4], 11]]").desugar())))

        assertEquals("[add, [mul, 11, [add, [add, 3, 4], 11]], [mul, 11, [add, [add, 3, 4], 11]]]",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .unparse()
            )
    }
#+end_src
As you can see, substitutions can be as complex as we want them to be.
Now it is good time to do something about evaluation.
** improving taking into account the variables.
At this point we know how to substitute variables, and we also know how to evaluate expressions.
So mixing these two together we will get the evaluation process.
#+begin_src kotlin
        assertEquals("10",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1).unparse())

        assertEquals("25",
            parse("[mul, x, x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1)
                .unparse())

        assertEquals("30",
            parse("[add, [mul, x, x], x]").desugar()
                .substitute(ESymbol("x"), env1)
                .eval(env1)
                .unparse())

#+end_src
these examples would work, evaluation is simple and straghtforward

#+begin_src kotlin
        assertEquals("[add, [mul, 5, y], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .eval(env1)
                .unparse())

#+end_src
and this will error out.
Because we cannot evaluate the symbol ' y'

As you can see for the evaluation it is really important to substitute all the variables before we do the evaluation. Otherwise we would get as what is know as 'variable not found' exception.

this is easily fixable. We just need to substitute 'y' as well
#+begin_src kotlin
        assertEquals("[add, [mul, 5, y], 5]",
            parse("[add, [mul, x, y], x]").desugar()
                .substitute(ESymbol("x"), env2)
                .substitute(ESymbol("y"), env2)
                .eval(env1)
                .unparse())
#+end_src

Now it is green.

In you looked carefully, you might see that substitution uses env2 for both variables, while evaluation uses 'env1'. This shows us flexibility the interpreter shows. But at the same time it reminds us how careful we should be about passing the correct environment.

Some might ask - why do we need to pass environment during the substitugion phase?
Can't it be taken from the environment during the evaluation phase?
Very good question. It could  be done that way, but you well need to do foreach replacement for every variable in the environment. While the expression itself might use only oe or two of them. Or manybe none at all.

** What if our variables are more complex than simple constants?
Prevously our values for 'x' and 'y' were simple constants. But what if we want them to be expressions?
What needs to be changed, and how much effort would it require to make evaluation aware of more complicated expressions?

Let us start with the simple one
#+begin_src yaml
# env : {x = [add, 40,2]}
[add, x, x]
#+end_src

Actually we have several options
We can substitute the value, or we can evaluate the value.

Substitution example we've seen previously.
#+begin_src kotlin
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

    // we are replacing 'x' with the expression it is bound to
        assertEquals("[add, [add, 10, 33], [add, 10, 33]]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

        // and then we can do the evaluation
        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
#+end_src

Upside of this approach is that is straightforward. You know exaclty what is happening and why it is happening by just looking on the expression.

But we can do something more interesting here.
What if we evaluates 'x' before we do the substitution?
after all, we know how to evaluate expresisons. And 'x' is an expresison in this scenario.
Why not just do it?

For that we would need to change our substitution function for the symbol
currently it looks like this
#+begin_src kotlin
data class ESymbol(val name:String):Expression{

   // ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        // we are just looking for the symbol in the environment
        if(symbol.name == name){
            return env.get(symbol)
        }
        return this
    }
    // ...

}

#+end_src

Now instead of simply getting symbol value from environment we are evaluating it first.

#+begin_src kotlin
data class ESymbol(val name:String):Expression{

 // ...
    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){
            // this part remains the same, getting value out of env
            val initialExpression = env.get(symbol)

            // evaluating the symbol in the same environment
            val evaluated = initialExpression.eval(env)

            // saving evaluated expression back to the environment
            env.bindings[symbol] = evaluated

            return evaluated
        }
        return this
    }
    // ...

}
#+end_src

Unfortunately, our test will be broken now and will fail with the following exception
#+begin_src kotlin
       val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("[add, [add, 10, 33], [add, 10, 33]]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

Expected :[add, [add, 10, 33], [add, 10, 33]]
Actual   :[add, 43, 43]
#+end_src

Any ideas why it happened?
Of course, previously we were substituting the 'x' with explicit value '[add, 10, 33]'.
And now we are replacing it with the computed value '43' in this case.

Adjusted unit test would look like this

#+begin_src kotlin
    @Test
    fun testComplicatedExpression(){
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("[add, 43, 43]",
        parse("[add, x, x]").desugar()
            .substitute(ESymbol("x"), complexEnv)
            .unparse())

        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
    }
#+end_src

What else has changed?
Well now we are more computationally efficient: 'x' is calculated only once, during the substitution phase.

We can go even further - add flag 'computed' to the symbol, so we don't call 'evaluate' more than once.

#+begin_src kotlin
 data class ESymbol(val name:String):Expression{
// we've added the evaluated flag to know if this symbol has been already evaluated
     var evaluated = false

    override fun eval(env: Environment): Expression {
        return this
    }

    override fun substitute(symbol: ESymbol, env: Environment): Expression {
        if(symbol.name == name){

            val initialExpression = env.get(symbol)
            // if it has been evaluated, we just return the result
            if(this.evaluated){
                return initialExpression
            }

            // otherwise we are executing the evaluation
            val evaluatedSymbol = initialExpression.eval(env)

            // save the result in the environment
            env.bindings[symbol] = evaluatedSymbol
            // and updateing the evaluated flag
            this.evaluated = true
            return evaluatedSymbol
        }
        return this
    }

    override fun unparse(): String {
        return name
    }
}
#+end_src

No matter how many times 'x' will be referenced during the calculations it will be calculated only once.
This fact remains true for any variable we are substituting in the expression.

Let's look at our test one more time.
Can we improve something here?
#+begin_src kotlin
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("86",
            parse("[add, x, x]").desugar()
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())
#+end_src

We are calling `substitute` before the evaluting expression.
Which is fine, but can we do this substitution right inside of evaluation?
After all symbol knows how to substitute itself given the environment?

What if we do somehting like this:

#+begin_src kotlin
 data class ESymbol(val name:String):Expression{
     var evaluated = false

    override fun eval(env: Environment): Expression {
        // now instead of returning the symbol itself
        // we're returning the substitution of it
        // this means every symbol is evaluated only once.

        return substitute(this, env)
        // return this;
    }

#+end_src

And now the test might be simplified a little bit
#+begin_src kotlin
        val complexEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        assertEquals("86",
            parse("[add, x, x]").desugar()
            // substitution would still work
            // and provide the same result
                .substitute(ESymbol("x"), complexEnv)
                .eval(Environment(hashMapOf()))
                .unparse())


        assertEquals("86",
            parse("[add, x, x]").desugar()
                // passing complex environmet to the expression
                // no need to substitute manually
                .eval(complexEnv)
                .unparse())
#+end_src


let's change the evironment and see if our result changes as well.

#+begin_src kotlin
    @Test
    fun testingSameExpressionDifferentEnvironment(){
        val firstEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        val firstExpression=parse("[add, x, x]").desugar()

        assertEquals("86",
            firstExpression
                .eval(firstEnv)
                .unparse())

        val secondEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 20, 11]").desugar())))
        val secondExpression=parse("[add, x, x]").desugar()
        assertEquals("62",
            secondExpression
                .eval(secondEnv)
                .unparse())

    }
#+end_src

We have two indentical expressions `[add, x, x]`
and their evaluation results changes if we change the environment.
Now our programs has become way more generic. Defining variables and evaluating them in differnt contexts is extremely powerful tool.
We will use to work with functions. But not's let get ahead of ourselves.

What whould happen if we use single expression in both tests?
would it work? Any guesses?
#+begin_src kotlin
    @Test
    fun testingExactlySameExpressionDifferentEnvironment(){
        val firstEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 10, 33]").desugar())))

        val expression=parse("[add, x, x]").desugar()

        assertEquals("86",
            expression
                .eval(firstEnv)
                .unparse())

        val secondEnv = Environment(hashMapOf(Pair(ESymbol("x"),
            parse("[add, 20, 11]").desugar())))
        assertEquals("62",
            expression
                .eval(secondEnv)
                .unparse())

    }
#+end_src

Almost the same example. But now we have one expression evaluated in two different environments.
And it fails on the second one with very strange error.

#+begin_src kotlin
java.lang.ClassCastException: class EAdd cannot be cast to class EInt (EAdd and EInt are in unnamed module of loader 'app')

	at EAdd.eval(Domain.kt:44)
#+end_src

Why is that? How come that seemingly indentical tests behave differently?

Maybe it depends on the environment itself? But no.
If we change the place of `firstEnv` and `secondEnv` we would still get the same error.

Something fishy is going on here. Let's have a closer look
** Mutalbe vs immutable variables
* Adding variables to the mix
**   should variables have a type?
** adding environment to our expressions
** if you change the environment, expression changes as well.
** adding string support to the language

**   powers, exponents, mods and so on
* Evaluating parameters of the funciton. Order matters
** lazy vs eager evaluation. Pros, cons, implementation
* Adding functions to the language.
** function definition syntax
** function calls syntax
** What should happen if you define function within the function?
** What should happen if you call function within the function?
** Few words on recursive calls
* Adding conditional expressions
** adding boolean expression to the language
** adding IFs to the mix
** control flow is not as straighforward as you might think of it
* Adding lists to the language
** how generic is your generic?
** how generic is your function?
** adding foreach
** adding list comprehension
* Typing and optimisation. part 2
* Something about evaluation speed

** environments again
** tail call optimisation
** JZ, JNZ, JMP, Lisp & WebAssembly
* Adding types to the language
** number vs float vs int32 vs int64
** function should know about types as well
* Minimal required type theory
** Why golang avoided generics for so long
** How to read typing expressions
* type inferencing  the language. Simple version
* Generating WebAssembly for fun and profit
* Generating JVM based things for fun and profit
* type inferencing on steroids
** How haskell, scala and friends work under the hood
